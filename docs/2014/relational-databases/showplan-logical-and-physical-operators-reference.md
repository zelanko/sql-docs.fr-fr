---
title: Guide de référence des opérateurs Showplan logiques et physiques
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology:
- database-engine
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 97130c8e9a0a32a3719ed745565fce4a511d0dd3
ms.sourcegitcommit: 3da2edf82763852cff6772a1a282ace3034b4936
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/02/2018
ms.locfileid: "48161339"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guide de référence des opérateurs Showplan logiques et physiques
  Les opérateurs décrivent comment [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] exécute une requête ou une instruction DML (Data Manipulation Language). L'optimiseur de requête utilise des opérateurs pour construire un plan de requête qui crée le résultat spécifié dans la requête ou pour exécuter l'opération spécifiée dans l'instruction DML. Le plan de requête est une arborescence composée d'opérateurs physiques. Vous pouvez afficher le plan de requête à l'aide des instructions SET SHOWPLAN, des options plan d'exécution graphique dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou des classes d'événements Showplan de SQL Server Profiler.  
  
 Les opérateurs sont classés en opérateurs logiques et physiques.  
  
 **Opérateurs logiques**  
 Les opérateurs logiques décrivent l'opération algébrique relationnelle utilisée pour traiter une instruction. En d'autres termes, les opérateurs logiques décrivent de manière conceptuelle les opérations à exécuter.  
  
 **Opérateurs physiques**  
 Les opérateurs physiques mettent en œuvre l'opération décrite par des opérateurs logiques. Chaque opérateur physique désigne un objet ou une routine chargée d'effectuer une opération. Par exemple, certains opérateurs physiques permettent d'accéder à des colonnes ou des lignes à partir d'une table, d'un index ou d'une vue. D'autres opérateurs physiques exécutent d'autres opérations telles que des calculs, des agrégations, des contrôles de l'intégrité des données vérifie ou des jointures. Des coûts sont associés aux opérateurs physiques.  
  
 Les opérateurs physiques s'initialisent, collectent des données et se ferment. En particulier, l'opérateur physique peut répondre aux trois méthodes d'appel suivantes :  
  
-   **Init()**: avec la méthode **Init()** , l’opérateur physique s’initialise et configure les structures de données nécessaires. Il arrive que l’opérateur physique reçoive beaucoup d’appels **Init()** , bien qu’en général il n’en reçoive qu’un.  
  
-   **GetNext()**: avec la méthode **GetNext()** , l’opérateur physique récupère la première ligne de données ou la suivante. L’opérateur physique peut recevoir zéro ou de nombreux appels **GetNext()** .  
  
-   **Close()**: avec la méthode **Close()** , l’opérateur physique effectue certaines opérations de nettoyage et se ferme. Un opérateur physique reçoit un seul appel **Close()** .  
  
 La méthode **GetNext()** renvoie une ligne de données, et le nombre d’appels qu’elle reçoit s’affiche sous **ActualRows** dans le résultat Showplan produit au moyen de SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Pour plus d’informations sur ces options SET, consultez [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) et [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Les compteurs **ActualRebinds** et **ActualRewinds** qui s’affichent dans le résultat de Showplan indiquent le nombre de fois que la méthode **Init()** est appelée. Sauf si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, **ActualRebinds** est égal à un et **ActualRewinds** est égal à zéro. Si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, le nombre total de reliaisons et de rembobinages doit être égal au nombre de ligne traitées sur le côté extérieur de la jointure. Une reliaison signifie qu'un ou plusieurs des paramètres corrélés de la jointure ont changé, et que le côté intérieur doit être réévalué. Un rembobinage signifie qu'aucun des paramètres corrélés n'a changé, et que l'ancien jeu de résultats interne peut être réutilisé.  
  
 **ActualRebinds** et **ActualRewinds** sont présents dans le résultat de Showplan XML produit en utilisant SET STATISTICS XML ON. Ils ne sont remplis que pour le **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, et  **Table-valued Function** opérateurs. **ActualRebinds** et **ActualRewinds** peuvent aussi être remplis pour le `Assert` et **filtre** opérateurs lorsque le **StartupExpression** attribut est définie sur TRUE.  
  
 Lorsque **ActualRebinds** et **ActualRewinds** sont présents dans un Showplan XML, ils sont comparables à **EstimateRebinds** et **EstimateRewinds**. S’ils sont absents, le nombre estimé de lignes (**EstimateRows**) est comparable au nombre réel de lignes (**ActualRows**). Sachez que le résultat du Showplan graphique réel affiche des zéros pour les reliaisons réelles et les rembobinages réels lorsqu'ils sont absents.  
  
 Un compteur apparenté, **ActualEndOfScans**, est disponible uniquement si le résultat de Showplan est produit au moyen de SET STATISTICS XML ON. Chaque fois qu'un opérateur physique atteint la fin de son flux de données, le compteur est incrémenté de un. Un opérateur physique peut atteindre la fin de son flux de données zéro, une ou de nombreuses fois. Comme pour les reliaisons et les rembobinages, le nombre de fins d'analyses ne peut être supérieur à un que si l'opérateur se situe sur le côté intérieur d'une jointure de boucles. Le nombre de fins d'analyses doit être inférieur ou égal au nombre total des reliaisons et des rembobinages.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mappage d'opérateurs physiques et logiques  
 L'optimiseur de requête crée un plan de requête sous forme d'arborescence d'opérateurs logiques. Après avoir créé le plan, l'optimiseur de requête choisit l'opérateur physique le plus efficace pour chaque opérateur logique. L'optimiseur de requête utilise une approche basée sur les coûts pour déterminer l'opérateur physique qui mettra en œuvre un opérateur logique.  
  
 Généralement, une opération logique peut être mise en œuvre par plusieurs opérateurs physiques. Toutefois, en de rares occasions, un opérateur physique peut également mettre en œuvre plusieurs opérations logiques.  
  
## <a name="operator-descriptions"></a>Description des opérateurs  
 Cette section contient la description des opérateurs logiques et physiques.  
  
|Icône du plan d'exécution graphique|Opérateur Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|L'opérateur `Aggregate` calcule une expression contenant MIN, MAX, SUM, COUNT ou AVG. L'opérateur `Aggregate` peut être un opérateur logique ou physique.|  
|![Icône d’opérateur Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icône d’opérateur Arithmetic Expression")|`Arithmetic Expression`|L'opérateur `Arithmetic Expression` calcule une nouvelle valeur à partir de valeurs existantes dans une ligne. `Arithmetic Expression` n’est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur Assert](../../2014/database-engine/media/assert-32x.gif "Icône d’opérateur Assert")|`Assert`|Le `Assert` opérateur vérifie une condition. Par exemple, il valide l'intégrité référentielle ou garantit qu'une sous-requête scalaire retourne une ligne. Pour chaque ligne d’entrée, le `Assert` opérateur évalue l’expression dans la `Argument` colonne plan d’exécution. Si cette expression a pour résultat NULL, l'opérateur `Assert` passe la ligne et la requête d'exécution se poursuit. Si cette expression a pour résultat une valeur non NULL, l'erreur correspondante est levée. Le `Assert` opérateur est un opérateur physique.|  
|![Icône de l’élément de langage Assign](../../2014/database-engine/media/assign-32.gif "Icône de l’élément de langage Assign")|`Assign`|Le `Assign` opérateur assigne la valeur d’une expression ou une constante à une variable. `Assign` est un élément de langage.|  
|None|`Asnyc Concat`|Le `Asnyc Concat` opérateur est utilisé uniquement dans les requêtes distantes (requêtes distribuées). Elle a *n* enfants et un nœud parent. En règle générale, certains des enfants sont des ordinateurs distants qui participent à une requête distribuée. `Asnyc Concat` problèmes `open()` appelle à tous les enfants simultanément et applique ensuite une bitmap à chacun d’eux. Pour chaque bit est 1, `Async Concat` envoie les lignes de sortie vers le nœud parent à la demande.|  
|![Icône d’opérateur Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icône d’opérateur Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] utilise le `Bitmap` opérateur pour implémenter le filtrage bitmap dans les plans de requête parallèles. Filtrage bitmap accélère l’exécution des requêtes en éliminant les lignes avec des valeurs de clé qui ne peuvent pas produire d’enregistrements de jointure avant de transmettre les lignes à un autre opérateur tel que le `Parallelism` opérateur. Un filtre Bitmap utilise une représentation compacte d'un ensemble de valeurs d'une table dans une partie de l'arborescence de l'opérateur pour filtrer les lignes d'une seconde table dans une autre partie de l'arborescence. Avec la suppression des lignes inutiles tôt dans la requête, les opérateurs suivants ont moins de lignes à traiter et les performances globales de la requête sont améliorées. L'optimiseur détermine quand un filtre Bitmap est suffisamment sélectif pour être utile et dans quels opérateurs le filtre doit être appliqué. `Bitmap` est un opérateur physique.|  
|![Icône d’opérateur Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icône d’opérateur Bitmap")|`Bitmap Create`|L'opérateur `Bitmap Create` apparaît dans la sortie de plan d'exécution de requêtes où les bitmaps sont construites. `Bitmap Create` est un opérateur logique.|  
|![Icône d’opérateur Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|`Bookmark Lookup`|Le `Bookmark Lookup` opérateur utilise un signet (ID de ligne ou clé de clustering) pour rechercher la ligne correspondante dans la table ou un index cluster. Le `Argument` colonne contient l’étiquette de signet utilisée pour rechercher la ligne dans la table ou un index cluster. Le `Argument` colonne contient également le nom de la table ou un index cluster dans lequel la ligne est recherchée. Si la clause WITH PREFETCH apparaît dans la `Argument` colonne, le processeur de requêtes a déterminé qu’il est souhaitable d’utiliser asynchrone prérécupération (lecture anticipée) lors de la recherche de signets dans la table ou un index cluster.<br /><br /> `Bookmark Lookup` n’est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. À la place, `Clustered Index Seek` et `RID Lookup` fournissent des fonctionnalités de recherche de signet. L'opérateur `Key Lookup` fournit également ces fonctionnalités.|  
|None|`Branch Repartition`|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs `Parallelism` d'une région distincte sont appelés `Branch Repartition`. L'itérateur `Parallelism` situé à la limite de deux régions de ce type est appelé `Segment Repartition`. `Branch Repartition` et `Segment Repartition` sont des opérateurs logiques.|  
|None|`Broadcast`|`Broadcast` possède un nœud enfant et *n* nœuds parents. `Broadcast` envoie ses lignes d'entrée à plusieurs consommateurs à la demande. Chaque consommateur obtient toutes les lignes. Par exemple, si tous les consommateurs se trouvent des côtés construction d'une jointure de hachage, *n* copies des tables de hachage sont générées.|  
|![Icône d’opérateur Build Hash](../../2014/database-engine/media/build-hash.gif "Icône d’opérateur Build Hash")|`Build Hash`|Indique la création d'une table de hachage de lot pour un index columnstore optimisé en mémoire xVelocity.|  
|None|`Cache`|`Cache` est une version spécialisée de la **Spool** opérateur. Il ne stocke qu'une seule ligne de données. `Cache` est un opérateur logique. `Cache` n’est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icône d’opérateur Clustered Index Delete")|`Clustered Index Delete`|L'opérateur `Clustered Index Delete` supprime des lignes de l'index cluster spécifié dans la colonne Argument du plan d'exécution de requête. Si un prédicat WHERE  :() est présent dans la colonne Argument, puis uniquement les lignes répondant au prédicat sont supprimées.`Clustered Index Delete` est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icône d’opérateur Clustered Index Insert")|`Clustered Index Insert`|L'opérateur `Clustered Index Insert` Showplan insère des lignes de son entrée dans l'index cluster spécifié dans la colonne Argument. Cette colonne contient également un prédicat SET:(), qui indique la valeur à laquelle chaque colonne est définie. Si `Clustered Index Insert` a pas d’enfants pour les valeurs insert, la ligne insérée est extraite de la `Insert` opérateur lui-même.`Clustered Index Insert` est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Icône d’opérateur Clustered Index Merge")|**Clustered Index Merge**|L'opérateur **Clustered Index Merge** applique un flux de données de fusion à un index cluster. L’opérateur supprime, met à jour ou insère des lignes à partir de l’index cluster spécifié dans le `Argument` colonne de l’opérateur. L’opération réellement effectuée dépend de la valeur d’exécution de la **ACTION** colonne spécifiée dans le `Argument` colonne de l’opérateur. **Clustered Index Merge** est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icône d’opérateur Clustered Index Scan")|`Clustered Index Scan`|L'opérateur `Clustered Index Scan` analyse l'index cluster spécifié dans la colonne Argument du plan d'exécution de requête. Lorsqu'un prédicat facultatif WHERE:() y figure, seules les lignes répondant au prédicat sont retournées. Si la colonne Argument contient la clause ORDERED, cela signifie que le processeur de requêtes a demandé le renvoi des sorties de lignes dans l'ordre dans lequel l'index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. `Clustered Index Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icône d’opérateur Clustered Index Seek")|`Clustered Index Seek`|L'opérateur `Clustered Index Seek` utilise la capacité de recherche dans les index pour extraire des lignes d'un index cluster. Le `Argument` colonne contient le nom de l’index cluster utilisé et le prédicat SEEK  :(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant à ce prédicat SEEK:(). Il peut également inclure un prédicat WHERE: () dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:(), mais ceci est facultatif et ne fait pas appel aux index pour exécuter ce processus.<br /><br /> Si le `Argument` colonne contient la clause ORDERED, le processeur de requêtes a déterminé que les lignes doivent être retournées dans l’ordre dans lequel l’index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. Autoriser la sortie à conserver son classement peut s'avérer moins efficace que la production d'une sortie non triée. Lorsque le mot clé LOOKUP apparaît, une recherche de signet est alors exécutée. Dans [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] et versions ultérieures, le `Key Lookup` opérateur fournit la fonctionnalité de recherche de signet. `Clustered Index Seek` est un opérateur logique et physique.|  
|![Icône d’opérateur Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Icône d’opérateur Clustered Index Update")|`Clustered Index Update`|Le `Clustered Index Update` opérateur met à jour les lignes d’entrée dans l’index cluster spécifié dans le `Argument` colonne. Si un prédicat WHERE  :() est présent, seules les lignes répondant à ce prédicat sont mises à jour. Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. Si un prédicat DEFINE:() est présent, il établit la liste des valeurs définies par cet opérateur. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur, et ailleurs dans cette requête. `Clustered Index Update` est un opérateur logique et physique.|  
|![Icône d’opérateur Collapse](../../2014/database-engine/media/collapse-32x.gif "Icône d’opérateur Collapse")|`Collapse`|L'opérateur `Collapse` permet d'optimiser le traitement de mise à jour des données. Lorsqu’une mise à jour est effectuée, elle peut être divisée (à l’aide de la `Split` opérateur) en une suppression puis d’insertion. Le `Argument` colonne contient un clause GROUP BY  :() qui spécifie une liste de colonnes clés. Si le processeur de requêtes rencontre des lignes adjacentes d'instructions de suppression puis d'insertion des mêmes valeurs de clé, il regroupe alors ces opérations en une seule et même opération de mise à jour pour gagner en efficacité. `Collapse` est un opérateur logique et physique.|  
|![Analyse d'index columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Analyse d'index columnstore")|`Columnstore Index Scan`|Le `Columnstore Index Scan` opérateur analyse l’index columnstore spécifié dans le `Argument` colonne du plan de requête d’exécution.|  
|![Icône d’opérateur Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icône d’opérateur Compute Scalar")|`Compute Scalar`|Le `Compute Scalar` opérateur évalue une expression pour produire une valeur scalaire calculée. Celle-ci peut ensuite être retournée à l'utilisateur, référencée n'importe où dans la requête, ou les deux. Les deux sont utilisés par exemple dans un prédicat de filtre ou de jointure. `Compute Scalar` est un opérateur logique et physique.<br /><br /> `Compute Scalar` les opérateurs qui s’affichent dans les plans d’exécution générés par SET STATISTICS XML ne peuvent pas contenir le `RunTimeInformation` élément. Dans les plans d'exécution graphiques, **Actual Rows**, **Actual Rebinds**et **Actual Rewinds** peuvent être absents de la fenêtre **Propriétés** lorsque l'option **Inclure le plan d'exécution réel** est sélectionnée dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Si cela se produit, cela signifie que, même si ces opérateurs ont été utilisés dans le plan de requête compilé, leur travail a été exécuté par d'autres opérateurs dans le plan de requête à l'exécution. Notez également que le nombre d'exécutions figurant dans le résultat du plan d'exécution produit par SET STATISTICS PROFILE équivaut à la somme des reliaisons et des rembobinages des plans d'exécution produits par SET STATISTICS XML.|  
|![Icône d’opérateur Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Icône d’opérateur Concatenation")|**Concatenation**|L'opérateur **Concatenation** analyse plusieurs entrées et renvoie chaque ligne analysée. L'opérateur**Concatenation** sert généralement à implémenter la construction [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'opérateur physique **Concatenation** a deux entrées ou plus, et une sortie. L'opérateur Concatenation copie des lignes depuis le premier flux d'entrée vers le flux de sortie, puis répète l'opération pour chacun des autres flux d'entrée. **Concatenation** est un opérateur logique et physique.|  
|![Icône d’opérateur Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icône d’opérateur Constant Scan")|`Constant Scan`|Le `Constant Scan` opérateur introduit une ou plusieurs lignes de constante dans une requête. Un `Compute Scalar` opérateur est souvent utilisé après une `Constant Scan` pour ajouter des colonnes à une ligne produite par le `Constant Scan` opérateur.|  
|![Icône de l’élément de langage Convert (moteur de base de données)](../../2014/database-engine/media/convert-32x.gif "Icône de l’élément de langage Convert (moteur de base de données)")|`Convert`|L'opérateur `Convert` convertit une expression d'un type de données scalaire en un autre. `Convert` est un élément de langage.|  
|None|`Cross Join`|L'opérateur `Cross Join` relie chaque ligne de la première entrée (du haut) à chaque ligne de la deuxième entrée (du bas). `Cross Join` est un opérateur logique.|  
|![Icône d’opérateur Cursor Catchall](../../2014/database-engine/media/cursor-catch-all.gif "Icône d’opérateur Cursor Catchall")|`catchall`|L'icône catchall s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les éléments du langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Curseur**|Les opérateurs physiques et logiques de **curseur** sont utilisés pour décrire le mode d'exécution d'une requête ou d'une mise à jour impliquant des opérations de curseur. Les opérateurs physiques décrivent l'algorithme d'implémentation physique utilisé pour traiter le curseur, par exemple, à l'aide d'un curseur contrôlé par clés. Chaque étape de l'exécution d'un curseur implique un opérateur physique. Les opérateurs logiques décrivent une propriété du curseur, par exemple, le curseur est en lecture seule.<br /><br /> Les opérateurs logiques incluent Asynchronous, Optimistic, Primary, Read Only, Scroll Locks et Secondary et Synchronous.<br /><br /> Les opérateurs physiques incluent Dynamic, Fetch Query, Keyset, Population Query, Refresh Query et Snapshot.|  
|![Icône de l’élément de langage Declare](../../2014/database-engine/media/declare-32x.gif "Icône de l’élément de langage Declare")|`Declare`|Le `Declare` opérateur alloue une variable locale dans le plan de requête. `Declare` est un élément de langage.|  
|![Icône d’opérateur Delete (moteur de base de données)](../../2014/database-engine/media/delete-32x.gif "Icône d’opérateur Delete (moteur de base de données)")|`Delete`|Le `Delete` opérateur supprime d’un objet les lignes qui répondent au prédicat facultatif de la `Argument` colonne.|  
|![Icône d’opérateur Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Icône d’opérateur Delete Scan")|`Deleted Scan`|L'opérateur `Deleted Scan` analyse la table supprimée dans un déclencheur.|  
|None|`Distinct`|L'opérateur `Distinct` supprime les doublons d'un ensemble de lignes ou d'une collection de valeurs. `Distinct` est un opérateur logique.|  
|None|`Distinct Sort`|Le `Distinct Sort` opérateur logique analyse les entrées en éliminant les doublons et en triant les colonnes spécifiées dans le distinctes prédicat ORDER BY  :() de la `Argument` colonne. `Distinct Sort` est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icône d’opérateur de parallélisme Distribute Streams")|**Distribute Streams**|L'opérateur **Distribute Streams** est utilisé uniquement dans les plans de requête parallèles. L'opérateur **Distribute Streams** ne mobilise qu'un seul flux d'entrée d'enregistrements et produit plusieurs flux de sortie. Le contenu et le format des enregistrements ne sont pas modifiés. Chaque enregistrement provenant du flux d'entrée apparaît dans l'un des flux de sortie. Cet opérateur conserve automatiquement l'ordre relatif des enregistrements d'entrée dans les flux de sortie. Habituellement, le hachage est utilisé pour définir à quel flux de sortie appartient un enregistrement d'entrée particulier.<br /><br /> Si la sortie est partitionnée, puis le `Argument` colonne contient un prédicat PARTITION COLUMNS  :() et les colonnes de partitionnement. **Distribute Streams** est un opérateur logique.|  
|![Icône d’opérateur de curseur Dynamic](../../2014/database-engine/media/dynamic-32x.gif "Icône d’opérateur de curseur Dynamic")|`Dynamic`|Le `Dynamic` opérateur utilise un curseur qui peut voir toutes les modifications apportées par d’autres utilisateurs.|  
|![Icône d’opérateur Spool](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur Spool")|**Eager Spool**|Le **Eager Spool** l’opérateur accepte l’ensemble de l’entrée, stockant chaque ligne dans un objet temporaire masqué stocké dans le `tempdb` base de données. Si l’opérateur est réutilisé (par exemple, en un `Nested Loops` opérateur) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Eager Spool** crée le fichier spouleur avec « avidité » : lorsque l'opérateur parent du spool demande la première ligne, l'opérateur spool consomme toutes les lignes de son opérateur d'entrée et les stocke dans le spool. **Eager Spool** est un opérateur logique.|  
|![Icône d’opérateur de curseur Fetch Query](../../2014/database-engine/media/fetch-query-32x.gif "Icône d’opérateur de curseur Fetch Query")|`Fetch Query`|Le `Fetch Query` opérateur extrait des lignes lorsqu’une extraction est émise sur un curseur.|  
|![Icône d’opérateur Filter (moteur de base de données)](../../2014/database-engine/media/filter-32x.gif "Icône d’opérateur Filter (moteur de base de données)")|**Filter**|Le **filtre** opérateur analyse l’entrée et retourner uniquement les lignes qui répondent à l’expression de filtre (prédicat) qui apparaît dans les `Argument` colonne.|  
|None|`Flow Distinct`|Le `Flow Distinct` opérateur logique analyse les entrées en éliminant les doublons. Tandis que le `Distinct` opérateur mobilise toutes les entrées avant de produire une sortie, le **FlowDistinct** opérateur retourne chaque ligne, tel qu’il est obtenu à partir de l’entrée (sauf si cette ligne est un doublon, auquel cas elle est supprimée).|  
|None|`Full Outer Join`|Le `Full Outer Join` opérateur logique retourne chaque ligne répondant au prédicat de jointure de la première (haut) entrée joint à chaque ligne de la seconde (du bas) d’entrée. Il renvoie également les lignes de :<br /><br /> -la première entrée qui ne possède pas de correspondance dans la seconde entrée ;<br /><br /> -la seconde entrée sans correspondance dans la première entrée.<br /><br /> <br /><br /> L'entrée qui ne contient pas les valeurs correspondantes est retournée sous forme de valeur NULL. `Full Outer Join` est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Icône d’opérateur de parallélisme Gather Streams")|**Gather Streams**|L'opérateur **Gather Streams** n'est utilisé que dans les plans de requête parallèle. **Cet opérateur** mobilise plusieurs flux d'entrée et ne produit qu'un flux de sortie d'enregistrements en associant les flux d'entrée. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'opérateur conserve l'ordre, tous les flux d'entrée doivent alors être classés. Si la sortie est triée, la `Argument` colonne contient un prédicat ORDER BY  :() et les noms des colonnes classées. **Gather Streams** est un opérateur logique.|  
|![Icône d’opérateur Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icône d’opérateur Hash Match")|`Hash Match`|L'opérateur `Hash Match` crée une table de hachage en calculant une valeur de hachage pour chaque ligne à partir de son entrée de génération. Un prédicat HASH  :() avec une liste de colonnes utilisées pour créer une valeur de hachage apparaît dans la `Argument` colonne. Ensuite, il calcule, pour chaque ligne de sondage (le cas échéant), une valeur de hachage en utilisant la même fonction de hachage, et consulte la table de hachage pour trouver les correspondances. Si un prédicat résiduel (identifié par RESIDUAL  :() dans la `Argument` colonne), ce prédicat doit également être respecté pour être considérée comme une correspondance des lignes. Son comportement dépend de l'opération logique exécutée :<br /><br /> Pour toutes les jointures, utilisez la première entrée (du haut) pour créer la table de hachage et la seconde entrée (du bas) pour tester cette table. Les correspondances (ou non correspondances) de sortie sont dictées par le type de jointure. Si plusieurs jointures utilisent la même colonne de jointure, ces opérations sont regroupées dans une équipe de hachage.<br /><br /> Pour les opérateurs distincts ou d'agrégation, utilisez l'entrée pour créer la table de hachage (en supprimant les doublons et en calculant les expressions d'agrégation). Une fois la table de hachage construite, parcourez-la et sortez toutes les entrées.<br /><br /> Pour l'opérateur UNION, utilisez la première entrée pour créer la table de hachage (en supprimant les doublons). Utilisez la deuxième entrée (qui ne doit pas comporter de doublons) pour analyser la table de hachage, retourner toutes les lignes sans correspondance, puis analyser la table de hachage et retourner toutes les entrées.<br /><br /> <br /><br /> `Hash Match` est un opérateur physique.|  
|![Icône de l’élément de langage If](../../2014/database-engine/media/if-32x.gif "Icône de l’élément de langage If")|`If`|Le `If` opérateur effectue un traitement conditionnel basé sur une expression. `If` est un élément de langage.|  
|None|`Inner Join`|Le `Inner Join` opérateur logique retourne chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde (du bas) d’entrée.|  
|![Icône d’opérateur Insert (moteur de base de données)](../../2014/database-engine/media/insert-32x.gif "Icône d’opérateur Insert (moteur de base de données)")|`Insert`|Le `Insert` opérateur logique insère chaque ligne de son entrée dans l’objet spécifié dans le `Argument` colonne. L’opérateur physique est soit le `Table Insert`, `Index Insert`, ou `Clustered Index Insert` opérateur.|  
|![Icône d’opérateur Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icône d’opérateur Inserted Scan")|**Inserted Scan**|L'opérateur **Inserted Scan** analyse la table **insérée** . **Inserted Scan** est un opérateur logique et physique.|  
|![Icône de l’élément de langage Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Icône de l’élément de langage Intrinsic")|`Intrinsic`|Le `Intrinsic` opérateur appelle interne [!INCLUDE[tsql](../includes/tsql-md.md)] (fonction). `Intrinsic` est un élément de langage.|  
|![Icône d’opérateur Iterator Catchall](../../2014/database-engine/media/iterator-catch-all.gif "Icône d’opérateur Iterator Catchall")|`Iterator`|L'icône catchall `Iterator` s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|`Key Lookup`|Le `Key Lookup` opérateur est une recherche de signet sur une table avec un index cluster. Le `Argument` colonne contient le nom de l’index cluster et la clé de clustering utilisée pour rechercher la ligne dans l’index cluster. `Key Lookup` est toujours accompagné par un `Nested Loops` opérateur. Si la clause WITH PREFETCH apparaît dans la `Argument` colonne, le processeur de requêtes a déterminé qu’il est souhaitable d’utiliser asynchrone prérécupération (lecture anticipée) lors de la recherche de signets dans l’index cluster.<br /><br /> L’utilisation d’un `Key Lookup` opérateur dans un plan de requête indique que la requête peut bénéficier du réglage des performances. Par exemple, l'ajout d'un index explicatif peut améliorer les performances des requêtes.|  
|![Icône d’opérateur de curseur Keyset](../../2014/database-engine/media/keyset-32x.gif "Icône d’opérateur de curseur Keyset")|`Keyset`|L'opérateur `Keyset` utilise un curseur qui peut détecter les mises à jour, mais pas les insertions effectuées par d'autres.|  
|![Icône catchall Language Element](../../2014/database-engine/media/language-construct-catch-all.gif "Icône catchall Language Element")|`Language Element`|L'icône catchall `Language Element` s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur Spool](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur Spool")|**Lazy Spool**|Le **Lazy Spool** opérateur logique stocke chaque ligne de son entrée dans un objet temporaire masqué stocké dans le `tempdb` base de données. Si l’opérateur est réutilisé (par exemple, en un `Nested Loops` opérateur) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Lazy Spool** crée son fichier d'attente de manière « économique » : chaque fois que l'opérateur parent du fichier d'attente demande une ligne, l'opérateur en attente obtient une ligne de son opérateur d'entrée et la stocke dans le fichier d'attente, au lieu de consommer toutes les lignes simultanément. Lazy Spool est un opérateur logique.|  
|None|`Left Anti Semi Join`|L'opérateur `Left Anti Semi Join` retourne chaque ligne de la première entrée (du haut) lorsqu'il n'y a aucune ligne correspondante dans la seconde entrée (du bas). Si aucun prédicat de jointure n’existe dans le `Argument` colonne, chaque ligne est une ligne correspondante. `Left Anti Semi Join` est un opérateur logique.|  
|None|`Left Outer Join`|L'opérateur logique `Left Outer Join` renvoie chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde entrée (du bas). Il renvoie également toute ligne de la première entrée n'ayant pas de ligne en correspondance dans la seconde entrée. Les lignes sans correspondance dans la seconde entrée sont retournées sous forme de valeurs NULL. Si aucun prédicat de jointure n’existe dans le `Argument` colonne, chaque ligne est une ligne correspondante. `Left Outer Join` est un opérateur logique.|  
|None|`Left Semi Join`|Le `Left Semi Join` opérateur retourne chaque ligne de la première entrée (du haut) lorsqu’il existe une ligne correspondante dans la seconde entrée (du bas). Si aucun prédicat de jointure n’existe dans le `Argument` colonne, chaque ligne est une ligne correspondante. `Left Semi Join` est un opérateur logique.|  
|![Icône d’opérateur Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icône d’opérateur Log Row Scan")|`Log Row Scan`|Le `Log Row Scan` opérateur analyse le journal des transactions. `Log Row Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icône d’opérateur Merge Interval")|`Merge Interval`|Le `Merge Interval` opérateur fusionne plusieurs intervalles (susceptibles de se chevaucher) pour produire des intervalles minimaux, sans chevauchement qui sont ensuite utilisés pour rechercher des entrées d’index. Cet opérateur apparaît généralement au-dessus d’un ou plusieurs `Compute Scalar` opérateurs `Constant Scan` operators, qui créent les intervalles (représentés sous forme de colonnes dans une ligne) que l’opérateur fusionne. `Merge Interval` est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icône d’opérateur Merge Join")|**Merge Join**|L'opérateur **Merge Join** exécute les opérations logiques suivantes : inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join et union.<br /><br /> Dans le `Argument` colonne, le **Merge Join** opérateur contient un prédicat MERGE  :() si l’opération exécute une jointure un-à-plusieurs, ou un-à-plusieurs prédicat MERGE  :() si l’opération exécute une jointure plusieurs-à-plusieurs. Le `Argument` colonne inclut également une liste séparée par des virgules de colonnes utilisées pour effectuer l’opération. L'opérateur **Merge Join** nécessite deux entrées triées dans leurs colonnes respectives, peut-être par l'insertion d'opérations de tri explicites dans le plan de requête. L'opérateur Merge join est particulièrement efficace si le tri explicite n'est pas nécessaire, par exemple s'il existe un index B-tree approprié dans la base de données ou si l'ordre de tri peut être exploité pour plusieurs opérations, telles que jointure de fusion et regroupement par cumuls. **Merge Join** est un opérateur physique.|  
|![Icône d’opérateur Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Icône d’opérateur Nested Loops")|`Nested Loops`|L'opérateur `Nested Loops` réalise les opérations logiques Inner Join, Left Outer Join, Left Semi Join et Left Anti Semi Join. Les jointures de boucles imbriquées effectuent une recherche sur la table interne pour chaque ligne de la table externe, généralement en utilisant un index. Le processeur de requêtes décide, sur la base des coûts anticipés, de trier ou non l’entrée externe pour améliorer la localisation des recherches dans l’index de l’entrée interne. Toutes les lignes répondant au prédicat (facultatif) dans le `Argument` colonne sont retournées selon le cas, en fonction de l’opération logique en cours d’exécution. `Nested Loops` est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icône d’opérateur Nonclustered Index Delete")|`Nonclustered Index Delete`|Le `Nonclustered Index Delete` opérateur supprime des lignes d’entrée de l’index non-cluster spécifié dans le `Argument` colonne. `Nonclustered Index Delete` est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icône d’opérateur Nonclustered Index Insert")|`Index Insert`|Le `Index Insert` opérateur insère des lignes de son entrée dans l’index non-cluster spécifié dans le `Argument` colonne. Le `Argument` colonne contient également un prédicat SET  :(), ce qui indique la valeur à laquelle chaque colonne est définie. `Index Insert` est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icône d’opérateur Nonclustered Index Scan")|`Index Scan`|Le `Index Scan` opérateur extrait toutes les lignes de l’index non-cluster spécifié dans le `Argument` colonne. Si un prédicat WHERE facultatif  :() figure dans la `Argument` colonne, seules les lignes répondant au prédicat sont retournées. `Index Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Icône d’opérateur Nonclustered Index Seek")|`Index Seek`|Le `Index Seek` opérateur utilise la capacité de recherche d’index pour extraire des lignes à partir d’un index non cluster. Le `Argument` colonne contient le nom de l’index non-cluster utilisé. Il contient également le prédicat SEEK:(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant au prédicat SEEK:(). Il peut éventuellement inclure un prédicat WHERE:() dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:() ; il ne fait pas appel aux index pour exécuter ce processus. Si le `Argument` colonne contient la clause ORDERED, le processeur de requêtes a déterminé que les lignes doivent être retournées dans l’ordre dans lequel l’index non-cluster les a triées. Si la clause ORDERED n'apparaît pas, le moteur de stockage recherche dans l'index de façon optimale (sans garantie de tri de la sortie). Autoriser la sortie à conserver son ordre peut s'avérer moins efficace que la production d'une sortie non triée. `Index Seek` est un opérateur logique et physique.|  
|![Icône d’opérateur Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Icône d’opérateur Nonclustered Index Spool")|**Index spool**|Le **Index Spool** opérateur physique contient un prédicat SEEK  :() dans la `Argument` colonne. Le **Index Spool** opérateur analyse ses lignes d’entrée, en plaçant une copie de chaque ligne dans un fichier d’attente caché (stocké dans le `tempdb` base de données et existent uniquement pour la durée de vie de la requête) et construit un index non cluster sur les lignes. Ceci vous permet d'utiliser les capacités de recherche des index afin de ne sortir que les lignes répondant au prédicat SEEK:(). Si l’opérateur est réutilisé (par exemple, en un `Nested Loops` opérateur) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée.|  
|![Icône d’opérateur Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icône d’opérateur Nonclustered Index Update")|`Nonclustered Index Update`|Le `Nonclustered Index Update` opérateur physique met à jour les lignes de son entrée dans l’index non-cluster spécifié dans le `Argument` colonne. Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. `Nonclustered Index Update` est un opérateur physique.|  
|![Icône d’opérateur Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Icône d’opérateur Online Index Insert")|**Online Index Insert**|L'opérateur physique **Online Index Insert** indique qu'une opération de création, modification ou suppression d'index est effectuée en ligne. Autrement dit, les données de la table sous-jacente restent disponibles aux utilisateurs pendant l'opération d'index.|  
|None|`Parallelism`|Le `Parallelism` opérateur effectue la distribution de flux, la collecte de flux et la répartition des opérations logiques de flux. Le `Argument` colonnes peuvent contenir une prédicat PARTITION COLUMNS  :() avec une liste séparée par des virgules des colonnes de partitionnement. Le `Argument` colonnes peuvent également contenir un prédicat ORDER BY  :(), répertoriant les colonnes pour conserver l’ordre de tri durant le partitionnement. `Parallelism` est un opérateur physique.<br /><br /> Remarque : Si une requête a été compilée en tant qu’une requête parallèle, mais en cours d’exécution, il est exécuté comme une requête séquentielle, la sortie du Showplan générées par SET STATISTICS XML ou à l’aide de la **inclure le Plan d’exécution réel** option [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] ne contient pas le `RunTimeInformation` élément pour le `Parallelism` opérateur. Dans la sortie de SET STATISTICS PROFILE, le véritable nombre de lignes et le nombre réel d’exécutions afficheront zéros pour les `Parallelism` opérateur. Si des conditions se produit, cela signifie que le `Parallelism` opérateur a été utilisé uniquement pendant la compilation de requête et non dans le plan de requête d’exécution. Notez que certaines fois, les plans de requête parallèles sont exécutés séquentiellement si le serveur doit faire face à des charges concurrentes élevées.|  
|![Icône d’opérateur Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icône d’opérateur Parameter Table Scan")|`Parameter Table Scan`|Le `Parameter Table Scan` opérateur analyse une table qui agit en tant que paramètre dans la requête actuelle. Généralement, cet opérateur est utilisé dans une procédure stockée pour les requêtes INSERT. `Parameter Table Scan` est un opérateur logique et physique.|  
|None|**Partial Aggregate**|**Partial Aggregate** est utilisé dans des plans parallèles. Il applique une fonction d'agrégation à autant de lignes d'entrée que possible, afin que l'écriture sur le disque (appelé « débordement ») ne soit pas nécessaire. `Hash Match` est l’unique opérateur physique (itérateur) qui implémente une agréation de partition. **Partial Aggregate** est un opérateur logique.|  
|![Icône d’opérateur de curseur Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Icône d’opérateur de curseur Population Query")|`Population Query`|L'opérateur `Population Query` permet de renseigner la table de travail d'un curseur lorsque le curseur est ouvert.|  
|![Icône d’opérateur de curseur Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Icône d’opérateur de curseur Refresh Query")|`Refresh Query`|L'opérateur `Refresh Query` extrait les données courantes des lignes du tampon d'extraction.|  
|![Icône d’opérateur Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icône d’opérateur Remote Delete")|`Remote Delete`|Le `Remote Delete` opérateur supprime les lignes d’entrée à partir d’un objet distant. `Remote Delete` est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "Opérateur Showplan Remote Index Seek")|**Remote Index Scan**|L’opérateur **Remote Index Scan** analyse l’index distant spécifié dans la colonne Argument. **Remote Index Scan** est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "Opérateur Showplan Remote Index Seek")|**Remote Index Seek**|L'opérateur **Remote Index Seek** utilise les capacités de recherche d'un objet d'index distant pour extraire des lignes. Le `Argument` colonne contient le nom de l’index distant utilisé et le prédicat SEEK  :(). **Remote Index Seek** est un opérateur physique logique.|  
|![Icône d’opérateur Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icône d’opérateur Remote Insert")|**Remote Insert**|L'opérateur **Remote Insert** insère des lignes d'entrée dans un objet distant. **Remote Insert** est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icône d’opérateur Remote Query")|`Remote Query`|Le `Remote Query` opérateur soumet une requête à une source distante. Le texte de la requête envoyée au serveur distant apparaît dans la `Argument` colonne. `Remote Query` est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icône d’opérateur Remote Scan")|`Remote Scan`|Le `Remote Scan` opérateur analyse un objet distant. Le nom de l’objet distant apparaît dans la `Argument` colonne. `Remote Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icône d’opérateur Remote Update")|`Remote Update`|Le `Remote Update` opérateur met à jour les lignes d’entrée dans un objet distant. `Remote Update` est un opérateur logique et physique.|  
|![Icône d’opérateur de parallélisme Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icône d’opérateur de parallélisme Repartition Streams")|**Repartition Streams**|L'opérateur **Repartition Streams** consomme plusieurs flux et produit plusieurs flux d'enregistrements. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'optimiseur de requête utilise un filtre bitmap, le nombre de lignes dans le flux de sortie est réduit. Chaque enregistrement d'un flux d'entrée est placé dans un flux de sortie. Si l'opérateur conserve l'ordre de tri, tous les flux d'entrée seront classés et fusionnés en plusieurs flux de sortie triés. Si la sortie est partitionnée, la `Argument` colonne contient un prédicat PARTITION COLUMNS  :() et les colonnes de partitionnement. Si la sortie est triée, la `Argument` colonne contient un prédicat ORDER BY  :() et les colonnes classées. **Repartition Streams** est un opérateur logique. Cet opérateur n'est utilisé que dans les plans de requête en parallèle.|  
|![Icône de l’élément de langage Result](../../2014/database-engine/media/result-32x.gif "Icône de l’élément de langage Result")|`Result`|Le `Result` opérateur contient les données retournées à la fin d’un plan de requête. Il représente en général l'élément racine d'un plan d'exécution de requêtes. `Result` est un élément de langage.|  
|![Icône d’opérateur RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icône d’opérateur RID Lookup")|`RID Lookup`|`RID Lookup` une recherche de signet sur un segment de mémoire utilise un identificateur de ligne fourni (RID). Le `Argument` colonne contient l’étiquette de signet utilisée pour rechercher la ligne dans la table et le nom de la table dans laquelle la ligne est recherchée. `RID Lookup` est toujours accompagné par un opérateur NESTED LOOP JOIN. `RID Lookup` est un opérateur physique. Pour plus d'informations sur les recherches de signets, consultez «[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)» (en anglais) sur le blog MSDN SQL Server.|  
|None|`Right Anti Semi Join`|Le `Right Anti Semi Join` opérateur Sort chaque ligne de la seconde entrée (du bas) lorsqu’une ligne correspondante dans la première (haut) entrée n’existe pas. Une ligne correspondante se définit comme une ligne répondant au prédicat de la `Argument` colonne (si aucun prédicat n’existe, chaque ligne est une ligne correspondante). `Right Anti Semi Join` est un opérateur logique.|  
|None|`Right Outer Join`|Le `Right Outer Join` opérateur retourne chaque ligne répondant à la jointure de la seconde (du bas) d’entrée avec chaque ligne correspondante à partir de la première (haut) d’entrée. Il retourne également toutes les lignes de la seconde entrée qui n'ont pas de lignes correspondantes dans la première entrée, reliées par la valeur NULL. Si aucun prédicat de jointure n’existe dans le `Argument` colonne, chaque ligne est une ligne correspondante. `Right Outer Join` est un opérateur logique.|  
|None|`Right Semi Join`|L'opérateur `Right Semi Join` renvoie chaque ligne de la seconde entrée (du bas) s'il n'y a pas de ligne correspondante dans la première entrée (du haut). Si aucun prédicat de jointure n’existe dans le `Argument` colonne, chaque ligne est une ligne correspondante. `Right Semi Join` est un opérateur logique.|  
|![Icône d’opérateur Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icône d’opérateur Row Count Spool")|**Row Count Spool**|L'opérateur **Row Count Spool** analyse l'entrée en comptant le nombre de lignes présentes et en retournant ce même nombre de lignes exemptes de données. Cet opérateur est utilisé lorsqu'il est plus important de vérifier l'existence des lignes que les données qu'elles contiennent. Par exemple, si un `Nested Loops` opérateur exécute une opération left semi joint et que le prédicat de jointure s’applique à l’entrée interne, un spool du nombre de lignes peut être placé en haut de l’entrée interne de le `Nested Loops` opérateur. Le `Nested Loops` opérateur peut déterminer le nombre de lignes sorties par le spool du nombre de lignes (car les données réelles de la partie interne ne sont pas nécessaire) pour déterminer s’il faut retourner la ligne externe. **Row Count Spool** est un opérateur physique.|  
|![Icône d’opérateur Segment](../../2014/database-engine/media/segment-32x.gif "Icône d’opérateur Segment")|**Segment**|**Segment** est un opérateur logique et physique. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. Ces colonnes apparaissent en tant qu'arguments dans l'opérateur **Segment** . L'opérateur génère ensuite un segment à la fois.|  
|None|`Segment Repartition`|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs `Parallelism` d'une région distincte sont appelés `Branch Repartition`. L'itérateur `Parallelism` situé à la limite de deux régions de ce type est appelé `Segment Repartition`. `Branch Repartition` et `Segment Repartition` sont des opérateurs logiques.|  
|![Icône d’opérateur Sequence](../../2014/database-engine/media/sequence-32x.gif "Icône d’opérateur Sequence")|`Sequence`|Le `Sequence` opérateur gère des plans de mise à jour étendus. Il exécute, sur le plan fonctionnel, chaque entrée en séquence (de haut en bas). Chaque entrée est généralement une mise à jour d'un objet différent. Il ne retourne que les lignes provenant de sa dernière entrée (du bas). `Sequence` est un opérateur logique et physique.|  
|![Icône d’opérateur Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Icône d’opérateur Sequence Project")|`Sequence Project`|Le `Sequence Project` opérateur ajoute des colonnes pour effectuer des calculs sur un jeu ordonné. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. L'opérateur génère ensuite un segment à la fois. Ces colonnes s'affichent en tant qu'arguments dans l'opérateur `Sequence Project`. `Sequence Project` est un opérateur logique et physique.|  
|![Icône d’opérateur de curseur Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Icône d’opérateur de curseur Snapshot")|**Snapshot**|L'opérateur **Snapshot** crée un curseur qui ne voit pas les modifications apportées par les autres.|  
|![Icône d’opérateur Sort](../../2014/database-engine/media/sort-32x.gif "Icône d’opérateur Sort")|`Sort`|Le `Sort` opérateur trie toutes les lignes entrantes. Le `Argument` colonne contient un distinctes prédicat ORDER BY  :() si les doublons sont supprimés par cette opération, ou un prédicat ORDER BY  :() avec une liste séparée par des virgules des colonnes à trier. Les colonnes comportent le préfixe ASC si elles sont triées dans l'ordre ascendant, ou DESC si elles sont triées dans l'ordre descendant. `Sort` est un opérateur logique et physique.|  
|![Icône d’opérateur Split](../../2014/database-engine/media/split-32x.gif "Icône d’opérateur Split")|`Split`|Le `Split` opérateur est utilisé pour optimiser le traitement de la mise à jour. Il divise chaque opération de mise à jour en opérations DELETE et INSERT. `Split` est un opérateur logique et physique.|  
|![Icône d’opérateur Spool](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur Spool")|**Spool**|Le **Spool** opérateur enregistre un résultat de requête intermédiaire dans le `tempdb` base de données.|  
|![Icône d’opérateur Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icône d’opérateur Stream Aggregate")|`Stream Aggregate`|Le `Stream Aggregate` opérateur regroupe des lignes en une ou plusieurs colonnes et calcule une ou plusieurs expressions d’agrégation retournées par la requête. La sortie de cet opérateur peut être référencée par des opérateurs ultérieurs dans la requête, retournés au client, ou les deux. L'opérateur `Stream Aggregate` exige que l'entrée suive l'ordre des colonnes dans ses groupes. L'optimiseur utilise un opérateur `Sort` avant cet opérateur si les données ne sont pas déjà triées en raison d'un opérateur `Sort` précédent ou d'une recherche ou d'une analyse d'index triée. Dans l’instruction SHOWPLAN_ALL ou le plan d’exécution graphique dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], les colonnes du prédicat GROUP BY sont répertoriées dans le `Argument` colonne et les expressions d’agrégation sont répertoriées dans le **Defined Values** colonne. `Stream Aggregate` est un opérateur physique.|  
|![Icône d’opérateur Switch](../../2014/database-engine/media/switch-32x.gif "Icône d’opérateur Switch")|**Switch**|**Switch** est un type particulier d'itérateur de concaténation qui a *n* entrées. Une expression est associée à chaque opérateur **Switch** . Selon la valeur renvoyée par l’expression (entre 0 et *n*-1), **Switch** copie le flux d’entrée approprié dans le flux de sortie. L'une des utilisations de **Switch** consiste à implémenter des plans de requête impliquant des curseurs à avance rapide avec certains opérateurs tels que l'opérateur **TOP** . **Switch** est un opérateur logique et physique.|  
|![Icône d’opérateur Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icône d’opérateur Table Delete")|`Table Delete`|Le `Table Delete` opérateur physique supprime des lignes de la table spécifiée dans le `Argument` colonne du plan de requête d’exécution.|  
|![Icône d’opérateur Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icône d’opérateur Table Insert")|`Table Insert`|Le `Table Insert` opérateur insère des lignes de son entrée dans la table spécifiée dans le `Argument` colonne du plan de requête d’exécution. Le `Argument` colonne contient également un prédicat SET  :(), ce qui indique la valeur à laquelle chaque colonne est définie. Si `Table Insert` a pas d’enfants pour les valeurs insert, puis la ligne insérée est extraite de l’opérateur Insert lui-même. `Table Insert` est un opérateur physique.|  
|![Opérateur Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Opérateur Table Merge")|**Table Merge**|L'opérateur **Table Merge** applique un flux de données de fusion à un tas. L’opérateur supprime, met à jour ou insère des lignes dans la table spécifiée dans le `Argument` colonne de l’opérateur. L’opération réellement effectuée dépend de la valeur de l’exécution de la **ACTION** colonne spécifiée dans le `Argument` colonne de l’opérateur. **Table Merge** est un opérateur physique.|  
|![Icône d’opérateur Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icône d’opérateur Table Scan")|`Table Scan`|Le `Table Scan` opérateur extrait toutes les lignes de la table spécifiée dans le `Argument` colonne du plan de requête d’exécution. Si un prédicat WHERE  :() figure dans la `Argument` colonne, seules les lignes répondant au prédicat sont retournées. `Table Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|**Table Spool**|L'opérateur **Table Spool** analyse l'entrée et place une copie de chaque ligne dans une table d'attente cachée, qui est stockée dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) et qui n'existe que le temps de la requête. Si l’opérateur est réutilisé (par exemple, en un `Nested Loops` opérateur) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. **Table Spool** est un opérateur physique.|  
|![Icône d’opérateur Table Update](../../2014/database-engine/media/table-update-32x.gif "Icône d’opérateur Table Update")|`Table Update`|Le `Table Update` opérateur physique met à jour les lignes d’entrée dans la table spécifiée dans le `Argument` colonne du plan de requête d’exécution. Le prédicat SET:() détermine la valeur de chaque colonne mise à jour. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur et ailleurs dans cette requête.|  
|![Icône d’opérateur Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Icône d’opérateur Table-valued Function")|**Table-valued Function**|L’opérateur **Table-valued Function** évalue une fonction table ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) et stocke les lignes obtenues dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) . Lorsque les itérateurs parents demandent les lignes, **Table-valued Function** retourne les lignes à partir de `tempdb`.<br /><br /> Les requêtes avec des appels à des fonctions table génèrent des plans de requêtes avec l’itérateur **Table-valued Function** . La**fonction table** peut être évaluée avec différentes valeurs de paramètres :<br /><br /> **Lecteur XML de fonctions table** entre un BLOB XML en guise de paramètre et produit un ensemble de lignes représentant des nœuds XML dans l’ordre des documents XML. D'autres paramètres d'entrée peuvent limiter les nœuds XML renvoyés à un sous-ensemble d'un document XML.<br /><br /> **Lecteur XML de fonctions table avec filtre XPath** est un type spécial de **Fonction table de lecteur XML** qui limite la sortie aux nœuds XML qui satisfont à une expression XPath.<br /><br /> <br /><br /> **Table-valued Function** est un opérateur logique et physique.|  
|![Icône d’opérateur Top](../../2014/database-engine/media/top-32x.gif "Icône d’opérateur Top")|**Top**|L'opérateur **Top** analyse l'entrée et retourne uniquement le premier nombre ou pourcentage spécifié de lignes, éventuellement en fonction d'un ordre de tri. Le `Argument` colonne peut contenir une liste des colonnes qui sont en cours de vérification pour les liens. Dans les plans de mise à jour, l'opérateur **Top** renforce les limites du nombre de lignes. **Top** est un opérateur logique et physique. **Top** est un opérateur logique et physique.|  
|None|**Top N Sort**|**Top N Sort** est similaire à la `Sort` itérateur, sauf que seule la première *N* lignes sont requises, et pas l’ensemble des résultats. Pour de petites valeurs de *N*, le moteur d'exécution de requête de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] essaie de réaliser en mémoire la totalité de l'opération de tri. Pour des valeurs élevées de *N*, le moteur d'exécution de requête recourt à la méthode de tri plus générique, dans laquelle *N* n'est pas un paramètre.|  
|![Icône d’opérateur UDX (Extended)](../../2014/database-engine/media/udx-32x.gif "Icône d’opérateur UDX (Extended)")|`UDX`|Les opérateurs UDX (Extended Operators) implémentent l'une des nombreuses opérations XQuery et XPath dans [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tous les opérateurs UDX sont des opérateurs logiques et physiques.<br /><br /> Opérateur étendu (UDX) `FOR XML` est utilisé pour sérialiser l’ensemble de lignes relationnelles qu’il entre dans la représentation sous forme de XML dans une colonne BLOB dans une ligne de sortie. Il s'agit d'un opérateur d'agrégation XML qui tient compte de l'ordre.<br /><br /> L'opérateur UDX `XML SERIALIZER` est un opérateur d'agrégation XML qui tient compte de l'ordre. Il entre des lignes qui représentent des nœuds XML ou des valeurs scalaires XQuery dans un ordre de document XML et produit un objet BLOB XML sérialisé dans une colonne XML dans une ligne de sortie.<br /><br /> L'opérateur UDX `XML FRAGMENT SERIALIZER` est un type de `XML SERIALIZER` qui permet de traiter les lignes d'entrée représentant les fragments XML à insérer dans l'extension de modification de données d'insertion XQuery.<br /><br /> L'opérateur UDX `XQUERY STRING` évalue la valeur de la chaîne XQuery des lignes d'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient la valeur de chaîne de l'entrée.<br /><br /> L'opérateur UDX `XQUERY LIST DECOMPOSER` est un opérateur de décomposition de liste XQuery. Pour chaque ligne d'entrée représentant un nœud XML, il produit une ou plusieurs lignes représentant chacune une valeur scalaire contenant une valeur d'élément de liste si le type d'entrée est une liste XSD.<br /><br /> L'opérateur UDX `XQUERY DATA` évalue la fonction XQuery fn:data() dans l'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:data()**.<br /><br /> L'opérateur UDX `XQUERY CONTAINS` évalue la fonction XQuery fn:contains() dans l'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:contains()**.<br /><br /> Opérateur `UPDATE XML NODE` mises à jour un nœud XML dans la requête XQuery remplacement d’extension de modification de données dans le **modify()** méthode sur le type XML.|  
|None|**Union**|L'opérateur **Union** analyse plusieurs entrées en sortant chaque ligne analysée et en supprimant les doublons. **Union** est un opérateur logique.|  
|![Icône d’opérateur Update (moteur de base de données)](../../2014/database-engine/media/update-32x.gif "Icône d’opérateur Update (moteur de base de données)")|`Update`|Le `Update` opérateur met à jour chaque ligne de son entrée dans l’objet spécifié dans le `Argument` colonne du plan de requête d’exécution. `Update` est un opérateur logique. L'opérateur physique est `Table Update`, `Index Update` ou `Clustered Index Update`.|  
|![Icône de l’élément de langage While](../../2014/database-engine/media/while-32x.gif "Icône de l’élément de langage While")|`While`|Le `While` opérateur implémente le [!INCLUDE[tsql](../includes/tsql-md.md)] boucle while. `While` est un élément de langage|  
|![Icône d’opérateur Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|`Window Spool`|L'opérateur `Window Spool` développe chaque ligne dans un ensemble de lignes qui représente la fenêtre qui lui est associée. Dans une requête, la clause OVER définit la fenêtre dans un jeu de résultats de la requête et une fonction de fenêtre calcule ensuite une valeur pour chaque ligne de la fenêtre. `Window Spool` est un opérateur logique et physique.|  
  
  
