---
title: SQLSetStmtAttr, fonction | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 583639a5cd4680bf6cfcf03bbaf6ee9eb63adba8
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/08/2020
ms.locfileid: "68039648"
---
# <a name="sqlsetstmtattr-function"></a>Fonction SQLSetStmtAttr
**Conformité**  
 Version introduite : ODBC 3,0 conformité aux normes : ISO 92  
  
 **Résumé**  
 **SQLSetStmtAttr** définit les attributs liés à une instruction.  
  
> [!NOTE]
>  Pour plus d’informations sur le mappage de cette fonction par le gestionnaire de pilotes lorsqu’une application ODBC *3. x* utilise un pilote ODBC *2. x* , consultez [mappage des fonctions de remplacement pour la compatibilité descendante des applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntaxe  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Arguments  
 *StatementHandle*  
 Entrée Descripteur d’instruction.  
  
 *Attribut*  
 Entrée Option à définir, indiquée dans « Comments ».  
  
 *ValuePtr*  
 Entrée Valeur à associer à l' *attribut*. Selon la valeur de l' *attribut*, *ValuePtr* est l’un des éléments suivants :  
  
-   Handle de descripteur ODBC.  
  
-   Valeur SQLUINTEGER.  
  
-   Valeur SQLULEN.  
  
-   Pointeur vers l’un des éléments suivants :  
  
    -   Chaîne de caractères terminée par le caractère null.  
  
    -   Mémoire tampon binaire.  
  
    -   Valeur ou tableau de type SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Valeur définie par le pilote.  
  
 Si l’argument d' *attribut* est une valeur spécifique au pilote, *ValuePtr* peut être un entier signé.  
  
 *StringLength*  
 Entrée Si l' *attribut* est un attribut défini par ODBC et que *ValuePtr* pointe vers une chaîne de caractères ou une mémoire tampon binaire, cet argument doit \*être la longueur de *ValuePtr*. Si l' *attribut* est un attribut défini par ODBC et que *ValuePtr* est un entier, *StringLength* est ignoré.  
  
 Si l' *attribut* est un attribut défini par le pilote, l’application indique la nature de l’attribut au gestionnaire de pilotes en définissant l’argument *StringLength* . *StringLength* peut avoir les valeurs suivantes :  
  
-   Si *ValuePtr* est un pointeur vers une chaîne de caractères, *StringLength* est la longueur de la chaîne ou SQL_NTS.  
  
-   Si *ValuePtr* est un pointeur vers une mémoire tampon binaire, l’application place le résultat de la macro SQL_LEN_BINARY_ATTR (*longueur*) dans *StringLength*. Cela place une valeur négative dans *StringLength*.  
  
-   Si *ValuePtr* est un pointeur vers une valeur autre qu’une chaîne de caractères ou une chaîne binaire, *StringLength* doit avoir la valeur SQL_IS_POINTER.  
  
-   Si *ValuePtr* contient une valeur de longueur fixe, *StringLength* est soit SQL_IS_INTEGER, soit SQL_IS_UINTEGER, selon le cas.  
  
## <a name="returns"></a>Retours  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostics  
 Lorsque **SQLSetStmtAttr** retourne SQL_ERROR ou SQL_SUCCESS_WITH_INFO, une valeur SQLSTATE associée peut être obtenue en appelant **SQLGetDiagRec** avec un *comme HandleType* de SQL_HANDLE_STMT et un *handle* de *StatementHandle*. Le tableau suivant répertorie les valeurs SQLSTATE couramment retournées par **SQLSetStmtAttr** et les explique dans le contexte de cette fonction. la notation « (DM) » précède les descriptions des SQLSTATEs retournées par le gestionnaire de pilotes. Le code de retour associé à chaque valeur SQLSTATE est SQL_ERROR, sauf indication contraire.  
  
|SQLSTATE|Error|Description|  
|--------------|-----------|-----------------|  
|01000|Avertissement général|Message d’information spécifique au pilote. (La fonction retourne SQL_SUCCESS_WITH_INFO.)|  
|01S02 ne|Valeur d’option modifiée|Le pilote ne prenait pas en charge la valeur spécifiée dans *ValuePtr*, ou la valeur spécifiée dans *ValuePtr* n’était pas valide en raison des conditions de travail de l’implémentation, donc le pilote remplaçait une valeur similaire. (**SQLGetStmtAttr** peut être appelé pour déterminer la valeur substituée temporairement.) La valeur de substitution est valide pour le *StatementHandle* jusqu’à la fermeture du curseur, auquel cas l’attribut d’instruction revient à sa valeur précédente. Les attributs d’instruction qui peuvent être modifiés sont les suivants :<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La fonction retourne SQL_SUCCESS_WITH_INFO.)|  
|08S01|Échec de la liaison de communication|Le lien de communication entre le pilote et la source de données à laquelle le pilote a été connecté a échoué avant la fin du traitement de la fonction.|  
|24 000|État de curseur non valide|L' *attribut* était SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS, et le curseur était ouvert.|  
|HY000|Erreur générale|Une erreur s’est produite pour laquelle aucune SQLSTATE spécifique n’a été définie et pour lesquelles aucune SQLSTATE spécifique à l’implémentation n’a été définie. Le message d’erreur retourné par **SQLGetDiagRec** dans * \** la mémoire tampon MessageText décrit l’erreur et sa cause.|  
|HY001|Erreur d’allocation de mémoire|Le pilote n’a pas pu allouer la mémoire requise pour prendre en charge l’exécution ou l’achèvement de la fonction.|  
|HY009|Utilisation non valide d’un pointeur null|L’argument d' *attribut* a identifié un attribut d’instruction qui nécessitait un attribut de chaîne et l’argument *ValuePtr* était un pointeur null.|  
|HY010|Erreur de séquence de fonction|(DM) une fonction d’exécution asynchrone a été appelée pour le handle de connexion associé à *StatementHandle*. Cette fonction asynchrone était toujours en cours d’exécution lors de l’appel de la fonction **SQLSetStmtAttr** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**ou **SQLMoreResults** a été appelé pour *StatementHandle* et a retourné SQL_PARAM_DATA_AVAILABLE. Cette fonction a été appelée avant que les données ne soient récupérées pour tous les paramètres transmis en continu.<br /><br /> (DM) une fonction d’exécution asynchrone a été appelée pour le *StatementHandle* et était toujours en cours d’exécution quand cette fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**ou **SQLSetPos** a été appelé pour *StatementHandle* et retourné SQL_NEED_DATA. Cette fonction a été appelée avant l’envoi des données pour l’ensemble des paramètres ou des colonnes de données en cours d’exécution.|  
|HY011|L’attribut ne peut pas être défini maintenant|L' *attribut* a été SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR ou SQL_ ATTR_USE_BOOKMARKS, et l’instruction a été préparée.|  
|HY013|Erreur de gestion de la mémoire|Impossible de traiter l’appel de fonction, car les objets mémoire sous-jacents sont inaccessibles, probablement en raison de conditions de mémoire insuffisante.|  
|HY017|Utilisation non valide d’un handle de descripteur alloué automatiquement|(DM) l’argument d' *attribut* était SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) l’argument d' *attribut* était SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et la valeur de *ValuePtr* était un handle de descripteur alloué implicitement autre que le handle initialement alloué pour ARD ou APD.|  
|HY024|Valeur d’attribut non valide|À partir de la valeur d' *attribut* spécifiée, une valeur non valide a été spécifiée dans *ValuePtr*. (Le gestionnaire de pilotes retourne ce SQLSTATE uniquement pour les attributs de connexion et d’instruction qui acceptent un ensemble discret de valeurs, telles que SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Pour tous les autres attributs de connexion et d’instruction, le pilote doit vérifier la valeur spécifiée dans *ValuePtr*.)<br /><br /> L’argument d' *attribut* était SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et *ValuePtr* était un handle de descripteur explicitement alloué qui ne se trouve pas sur la même connexion que l’argument *StatementHandle* .|  
|HY090|Longueur de chaîne ou de mémoire tampon non valide|(DM) * \*ValuePtr* est une chaîne de caractères, et l’argument *StringLength* a une valeur inférieure à 0 mais n’a pas été SQL_NTS.|  
|HY092|Identificateur d’attribut/option non valide|(DM) la valeur spécifiée pour l' *attribut* argument n’était pas valide pour la version de ODBC prise en charge par le pilote.<br /><br /> (DM) la valeur spécifiée pour l' *attribut* d’argument était un attribut en lecture seule.|  
|HY117|La connexion est interrompue en raison d’un état de transaction inconnu. Seules les fonctions de déconnexion et de lecture seule sont autorisées.|(DM) pour plus d’informations sur l’état suspendu, consultez [fonction SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Fonctionnalité facultative non implémentée|La valeur spécifiée pour l' *attribut* argument était un attribut d’instruction ODBC valide pour la version de ODBC prise en charge par le pilote, mais n’était pas pris en charge par le pilote.<br /><br /> L’argument d' *attribut* a été SQL_ATTR_ASYNC_ENABLE, et un appel à **SQLGetInfo** avec un *infotype* de SQL_ASYNC_MODE retourne SQL_AM_CONNECTION.<br /><br /> L’argument d' *attribut* a été SQL_ATTR_ENABLE_AUTO_IPD, et la valeur de l’attribut de connexion SQL_ATTR_AUTO_IPD a été SQL_FALSE.|  
|HYT01|Délai d’attente de connexion expiré|Le délai d’attente de connexion a expiré avant que la source de données ait répondu à la demande. Le délai d’expiration de la connexion est défini par le biais de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Le pilote ne prend pas en charge cette fonction|(DM) le pilote associé au *StatementHandle* ne prend pas en charge la fonction.|  
|S1118|Le pilote ne prend pas en charge la notification asynchrone|Si vous appelez **SQLSetStmtAttr** pour définir SQL_ATTR_ASYNC_STMT_EVENT ; la notification asynchrone n’est pas prise en charge par le pilote.|  
  
## <a name="comments"></a>Commentaires  
 Les attributs d’instruction d’une instruction restent en vigueur jusqu’à ce qu’ils soient modifiés par un autre appel à **SQLSetStmtAttr** ou jusqu’à ce que l’instruction soit supprimée en appelant **SQLFreeHandle**. L’appel de **SQLFreeStmt** avec l’option SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS ne réinitialise pas les attributs d’instruction.  
  
 Certains attributs d’instruction prennent en charge la substitution d’une valeur similaire si la source de données ne prend pas en charge la valeur spécifiée dans *ValuePtr*. Dans ce cas, le pilote retourne SQL_SUCCESS_WITH_INFO et SQLSTATE 01S02 ne (valeur d’option modifiée). Par exemple, si l' *attribut* est SQL_ATTR_CONCURRENCY et que *ValuePtr* est SQL_CONCUR_ROWVER et que la source de données ne le prend pas en charge, le pilote remplace SQL_CONCUR_VALUES et retourne SQL_SUCCESS_WITH_INFO. Pour déterminer la valeur substituée, une application appelle **SQLGetStmtAttr**.  
  
 Le format des informations définies avec *ValuePtr* dépend de l' *attribut*spécifié. **SQLSetStmtAttr** accepte les informations d’attribut dans l’un des deux formats différents : une chaîne de caractères ou une valeur entière. Le format de chaque est indiqué dans la description de l’attribut. Ce format s’applique aux informations retournées pour chaque attribut dans **SQLGetStmtAttr**. Les chaînes de caractères vers lesquelles pointe l’argument *ValuePtr* de **SQLSetStmtAttr** ont une longueur de *StringLength*.  
  
> [!NOTE]
>  La possibilité de définir des attributs d’instruction au niveau de la connexion en appelant **SQLSetConnectAttr** est dépréciée dans ODBC *3. x*. Les applications ODBC *3. x* ne doivent jamais définir d’attributs d’instruction au niveau de la connexion. Les attributs d’instruction ODBC *3. x* ne peuvent pas être définis au niveau de la connexion, à l’exception des attributs SQL_ATTR_METADATA_ID et SQL_ATTR_ASYNC_ENABLE, qui sont des attributs de connexion et des attributs d’instruction, et peuvent être définis au niveau de la connexion ou au niveau de l’instruction.  
> 
> [!NOTE]
>  Les pilotes ODBC *3. x* doivent uniquement prendre en charge cette fonctionnalité s’ils doivent fonctionner avec des applications ODBC *2. x* qui définissent les options d’instruction ODBC *2. x* au niveau de la connexion. Pour plus d’informations, consultez « Définition des options d’instruction au niveau de la connexion » sous le [mappage SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) dans l’annexe G : instructions relatives aux pilotes pour la compatibilité descendante.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributs d’instruction qui définissent des champs de descripteur  
 De nombreux attributs d’instruction correspondent à un champ d’en-tête d’un descripteur. La définition de ces attributs entraîne en fait la définition des champs de descripteur. La définition de champs par un appel à **SQLSetStmtAttr** plutôt qu’à **SQLSetDescField** présente l’avantage qu’il n’est pas nécessaire d’obtenir un handle de descripteur pour l’appel de fonction.  
  
> [!CAUTION]  
>  L’appel à **SQLSetStmtAttr** pour une instruction peut affecter d’autres instructions. Cela se produit lorsque le APD ou ARD associé à l’instruction est explicitement alloué et est également associé à d’autres instructions. Comme **SQLSetStmtAttr** modifie APD ou ARD, les modifications s’appliquent à toutes les instructions auxquelles ce descripteur est associé. Si ce n’est pas le comportement requis, l’application doit dissocier ce descripteur des autres instructions (en appelant **SQLSetStmtAttr** pour définir le champ SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC sur un autre handle de descripteur) avant d’appeler à nouveau **SQLSetStmtAttr** .  
  
 Lorsqu’un champ de descripteur est défini à la suite de l’attribut d’instruction correspondant défini, le champ est défini uniquement pour les descripteurs applicables actuellement associés à l’instruction identifiée par l’argument *StatementHandle* , et le paramètre d’attribut n’affecte pas les descripteurs qui peuvent être associés à cette instruction à l’avenir. Lorsqu’un champ de descripteur qui est également un attribut d’instruction est défini par un appel à **SQLSetDescField**, l’attribut d’instruction correspondant est défini. Si un descripteur alloué explicitement est dissocié d’une instruction, un attribut d’instruction qui correspond à un champ d’en-tête reprend la valeur du champ dans le descripteur alloué implicitement.  
  
 Lorsqu’une instruction est allouée (voir [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatre handles de descripteur sont automatiquement alloués et associés à l’instruction. Des handles de descripteur alloués explicitement peuvent être associés à l’instruction en appelant **SQLAllocHandle** avec un *fHandleType* de SQL_HANDLE_DESC pour allouer un handle de descripteur, puis en appelant **SQLSetStmtAttr** pour associer le handle du descripteur à l’instruction.  
  
 Les attributs d’instruction dans le tableau suivant correspondent aux champs d’en-tête de descripteur.  
  
|Attribut d’instruction|Champ d’en-tête|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributs d'instruction  
 Les attributs actuellement définis et la version de ODBC dans laquelle ils ont été introduits sont indiqués dans le tableau suivant : Il est supposé que davantage d’attributs seront définis par les pilotes pour tirer parti de différentes sources de données. Une plage d’attributs est réservée par ODBC ; les développeurs de pilotes doivent réserver des valeurs pour leur propre utilisation propre au pilote à partir d’Open Group. Pour plus d’informations, consultez [types de données spécifiques au pilote, types de descripteurs, types d’informations, types de diagnostics et attributs](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|Contenu *ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|Handle de APD pour les appels suivants à **SQLExecute** et **SQLExecDirect** sur le descripteur d’instruction. La valeur initiale de cet attribut est le descripteur alloué implicitement lors de l’allocation initiale de l’instruction. Si la valeur de cet attribut est définie sur SQL_NULL_DESC ou sur le descripteur alloué à l’origine pour le descripteur, un descripteur APD explicitement alloué avec le descripteur d’instruction en est dissocié et le descripteur d’instruction revient au handle APD alloué de manière implicite.<br /><br /> Cet attribut ne peut pas être défini sur un handle de descripteur qui a été implicitement alloué pour une autre instruction ou sur un autre handle de descripteur implicitement défini sur la même instruction. les handles de descripteurs alloués de manière implicite ne peuvent pas être associés à plusieurs instructions ou handles de descripteur.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|Handle de ARD pour les extractions suivantes sur le descripteur d’instruction. La valeur initiale de cet attribut est le descripteur alloué implicitement lors de l’allocation initiale de l’instruction. Si la valeur de cet attribut est définie sur SQL_NULL_DESC ou sur le descripteur alloué à l’origine pour le descripteur, un descripteur ARD explicitement alloué avec le descripteur d’instruction en est dissocié et le descripteur d’instruction revient au handle ARD alloué de manière implicite.<br /><br /> Cet attribut ne peut pas être défini sur un handle de descripteur qui a été implicitement alloué pour une autre instruction ou sur un autre handle de descripteur implicitement défini sur la même instruction. les handles de descripteurs alloués de manière implicite ne peuvent pas être associés à plusieurs instructions ou handles de descripteur.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Valeur SQLULEN qui spécifie si une fonction appelée avec l’instruction spécifiée est exécutée de façon asynchrone :<br /><br /> SQL_ASYNC_ENABLE_OFF = désactive la prise en charge de l’exécution asynchrone au niveau de l’instruction (valeur par défaut).<br /><br /> SQL_ASYNC_ENABLE_ON = activer la prise en charge de l’exécution asynchrone au niveau de l’instruction.<br /><br /> Pour plus d’informations, consultez [exécution asynchrone (méthode d’interrogation)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Pour les pilotes avec prise en charge de l’exécution asynchrone au niveau des instructions, l’attribut d’instruction SQL_ATTR_ASYNC_ENABLE est en lecture seule. Sa valeur est identique à la valeur de l’attribut de niveau de connexion portant le même nom au moment où le descripteur d’instruction a été alloué.<br /><br /> L’appel à **SQLSetStmtAttr** pour définir SQL_ATTR_ASYNC_ENABLE lorsque l' *InfoType* SQL_ASYNC_MODE retourne SQL_AM_CONNECTION retourne SQLState HYC00 (fonctionnalité facultative non implémentée). Pour plus d’informations, consultez [fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) pour plus d’informations.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Valeur SQLPOINTER qui est un handle d’événement.<br /><br /> La notification d’achèvement des fonctions asynchrones est activée en appelant **SQLSetStmtAttr** pour définir l’attribut **SQL_ATTR_ASYNC_STMT_EVENT** et spécifier le descripteur d’événement.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|SQLPOINTER à la fonction de rappel asynchrone.<br /><br /> Seul le gestionnaire de pilotes peut appeler la fonction **SQLSetStmtAttr** d’un pilote avec cet attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|SQLPOINTER à la structure de contexte<br /><br /> Seul le gestionnaire de pilotes peut appeler la fonction **SQLSetStmtAttr** d’un pilote avec cet attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Valeur SQLULEN qui spécifie l’accès concurrentiel du curseur :<br /><br /> SQL_CONCUR_READ_ONLY = le curseur est en lecture seule. Aucune mise à jour n’est autorisée.<br /><br /> SQL_CONCUR_LOCK = Cursor utilise le niveau de verrouillage le plus bas pour s’assurer que la ligne peut être mise à jour.<br /><br /> SQL_CONCUR_ROWVER = Cursor utilise le contrôle d’accès concurrentiel optimiste, en comparant les versions de ligne telles que SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor utilise le contrôle d’accès concurrentiel optimiste, en comparant les valeurs.<br /><br /> La valeur par défaut de SQL_ATTR_CONCURRENCY est SQL_CONCUR_READ_ONLY.<br /><br /> Cet attribut ne peut pas être spécifié pour un curseur ouvert. Pour plus d’informations, consultez [types d’accès concurrentiel](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si l' *attribut* SQL_ATTR_CURSOR_TYPE est remplacé par un type qui ne prend pas en charge la valeur actuelle de SQL_ATTR_CONCURRENCY, la valeur de SQL_ATTR_CONCURRENCY est modifiée au moment de l’exécution et un avertissement est émis lorsque **SQLExecDirect** ou **SQLPrepare** est appelé.<br /><br /> Si le pilote prend en charge l’instruction **Select for Update** et que cette instruction est exécutée alors que la valeur de SQL_ATTR_CONCURRENCY est définie sur SQL_CONCUR_READ_ONLY, une erreur est retournée. Si la valeur de SQL_ATTR_CONCURRENCY est remplacée par une valeur que le pilote prend en charge pour une valeur de SQL_ATTR_CURSOR_TYPE mais pas pour la valeur actuelle de SQL_ATTR_CURSOR_TYPE, la valeur de SQL_ATTR_CURSOR_TYPE est modifiée au moment de l’exécution et SQLSTATE 01S02 ne (valeur d’option modifiée) est émis lorsque **SQLExecDirect** ou **SQLPrepare** est appelé.<br /><br /> Si la concurrence spécifiée n’est pas prise en charge par la source de données, le pilote remplace un accès concurrentiel différent et retourne SQLSTATE 01S02 ne (valeur d’option modifiée). Par SQL_CONCUR_VALUES, le pilote remplace SQL_CONCUR_ROWVER, et vice versa. Par SQL_CONCUR_LOCK, le pilote remplace, dans l’ordre, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. La validité de la valeur substituée n’est pas vérifiée jusqu’au moment de l’exécution.<br /><br /> Pour plus d’informations sur la relation entre les SQL_ATTR_CONCURRENCY et les autres attributs de curseur, consultez [caractéristiques du curseur et type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Valeur SQLULEN qui spécifie le niveau de prise en charge requis par l’application. La définition de cet attribut affecte les appels suivants à **SQLExecDirect** et à **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = les curseurs à défilement ne sont pas requis sur le descripteur d’instruction. Si l’application appelle **SQLFetchScroll** sur ce handle, la seule valeur valide de *FetchOrientation* est SQL_FETCH_NEXT. Il s’agit de la valeur par défaut.<br /><br /> SQL_SCROLLABLE = les curseurs à défilement sont requis sur le descripteur d’instruction. Lors de l’appel de **SQLFetchScroll**, l’application peut spécifier n’importe quelle valeur valide de *FetchOrientation*, ce qui atteint le positionnement du curseur dans des modes autres que le mode séquentiel.<br /><br /> Pour plus d’informations sur les curseurs avec défilement, consultez [curseurs avec défilement](../../../odbc/reference/develop-app/scrollable-cursors.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SCROLLABLE et les autres attributs de curseur, consultez [caractéristiques du curseur et type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md) .|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Valeur SQLULEN qui spécifie si les curseurs sur le descripteur d’instruction rendent visibles les modifications apportées à un jeu de résultats par un autre curseur. La définition de cet attribut affecte les appels suivants à **SQLExecDirect** et à **SQLExecute**. Une application peut lire la valeur de cet attribut pour obtenir son état initial ou son état le plus récemment défini par l’application.<br /><br /> SQL_UNSPECIFIED = il n’est pas spécifié en quoi consiste le type de curseur et indique si les curseurs sur le descripteur d’instruction rendent visibles les modifications apportées à un jeu de résultats par un autre curseur. Les curseurs sur le descripteur d’instruction peuvent rendre visible aucune, certaines ou toutes ces modifications. Il s’agit de la valeur par défaut.<br /><br /> SQL_INSENSITIVE = tous les curseurs sur le descripteur d’instruction affichent le jeu de résultats sans refléter les modifications apportées par un autre curseur. Les curseurs non sensibles sont en lecture seule. Cela correspond à un curseur statique, qui a une concurrence qui est en lecture seule.<br /><br /> SQL_SENSITIVE = tous les curseurs sur le descripteur d’instruction rendent visible toutes les modifications apportées à un jeu de résultats par un autre curseur.<br /><br /> Pour plus d’informations sur la relation entre les SQL_ATTR_CURSOR_SENSITIVITY et les autres attributs de curseur, consultez [caractéristiques du curseur et type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Valeur SQLULEN qui spécifie le type de curseur :<br /><br /> SQL_CURSOR_FORWARD_ONLY = le curseur ne fait que faire défiler vers l’avant.<br /><br /> SQL_CURSOR_STATIC = les données du jeu de résultats sont statiques.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = le pilote enregistre et utilise les clés pour le nombre de lignes spécifié dans l’attribut d’instruction SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = le pilote enregistre et utilise uniquement les clés pour les lignes de l’ensemble de lignes.<br /><br /> La valeur par défaut est SQL_CURSOR_FORWARD_ONLY. Cet attribut ne peut pas être spécifié après la préparation de l’instruction SQL.<br /><br /> Si le type de curseur spécifié n’est pas pris en charge par la source de données, le pilote remplace un type de curseur différent et retourne SQLSTATE 01S02 ne (valeur d’option modifiée). Pour un curseur mixte ou dynamique, le pilote se substitue, dans l’ordre, à un curseur piloté par jeu de clés ou statique. Pour un curseur de jeu de clés, le pilote remplace un curseur statique.<br /><br /> Pour plus d’informations sur les types de curseurs avec défilement, consultez [types de curseurs avec défilement](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Pour plus d’informations sur la relation entre les SQL_ATTR_CURSOR_TYPE et les autres attributs de curseur, consultez [caractéristiques du curseur et type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Valeur SQLULEN qui spécifie si le remplissage automatique de l’IPD est effectué :<br /><br /> SQL_TRUE = active le remplissage automatique de la IPD après un appel à **SQLPrepare**. SQL_FALSE = désactive le remplissage automatique de l’IPD après un appel à **SQLPrepare**. (Une application peut toujours obtenir des informations de champ IPD en appelant **SQLDescribeParam**, si elle est prise en charge.) La valeur par défaut de l’attribut d’instruction SQL_ATTR_ENABLE_AUTO_IPD est SQL_FALSE. Pour plus d’informations, consultez [remplissage automatique de l’IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|SQLLEN \* qui pointe vers une valeur de signet binaire. Lorsque **SQLFetchScroll** est appelé avec *fFetchOrientation* égal à SQL_FETCH_BOOKMARK, le pilote récupère la valeur de signet de ce champ. Par défaut, ce champ est un pointeur null. Pour plus d’informations, consultez [défilement par signet](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> La valeur désignée par ce champ n’est pas utilisée pour les opérations de suppression par signet, mise à jour par signet ou extraction par signet dans **SQLBulkOperations**, qui utilisent des signets mis en cache dans les tampons d’ensemble de lignes.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|Handle de l’IPD. La valeur de cet attribut est le descripteur alloué lorsque l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** , mais n’est pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|Handle de IRD. La valeur de cet attribut est le descripteur alloué lorsque l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** , mais n’est pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|SQLULEN qui spécifie le nombre de lignes dans le jeu de clés pour un curseur de jeu de clés. Si la taille du jeu de clés est 0 (valeur par défaut), le curseur est entièrement piloté par jeu de clés. Si la taille du keyset est supérieure à 0, le curseur est mélangé (piloté par jeu de clés dans le jeu de clés et dynamique en dehors du jeu de clés). La taille du jeu de clés par défaut est 0. Pour plus d’informations sur les curseurs de jeu de clés, consultez [curseurs de jeu de clés](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si la taille spécifiée dépasse la taille de jeu de clés maximale, le pilote remplace cette taille et retourne SQLSTATE 01S02 ne (valeur d’option modifiée).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retourne une erreur si la taille du keyset est supérieure à 0 et inférieure à la taille de l’ensemble de lignes.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Valeur de SQLULEN qui spécifie la quantité maximale de données que le pilote retourne à partir d’une colonne de type caractère ou binaire. Si *ValuePtr* est inférieur à la longueur des données disponibles, **SQLFetch** ou **SQLGetData** tronque les données et retourne SQL_SUCCESS. Si *ValuePtr* est égal à 0 (valeur par défaut), le pilote tente de renvoyer toutes les données disponibles.<br /><br /> Si la longueur spécifiée est inférieure à la quantité minimale de données que la source de données peut retourner ou supérieure à la quantité maximale de données que la source de données peut retourner, le pilote remplace cette valeur et retourne SQLSTATE 01S02 ne (valeur d’option modifiée).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut ne pas prendre effet immédiatement, auquel cas le pilote retourne SQLSTATE 01S02 ne (valeur d’option modifiée) et rétablit l’attribut à sa valeur d’origine.<br /><br /> Cet attribut est destiné à réduire le trafic réseau et doit être pris en charge uniquement lorsque la source de données (par opposition au pilote) dans un pilote à plusieurs niveaux peut l’implémenter. Ce mécanisme ne doit pas être utilisé par les applications pour tronquer les données ; pour tronquer les données reçues, une application doit spécifier la longueur maximale de la mémoire tampon dans l’argument *BufferLength* dans **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Valeur SQLULEN correspondant au nombre maximal de lignes à retourner à l’application pour une instruction **Select** . Si \* *ValuePtr* est égal à 0 (valeur par défaut), le pilote retourne toutes les lignes.<br /><br /> Cet attribut est destiné à réduire le trafic réseau. D’un plan conceptuel, il est appliqué lorsque le jeu de résultats est créé et limite le jeu de résultats aux premières lignes *ValuePtr* . Si le nombre de lignes dans le jeu de résultats est supérieur à *ValuePtr*, le jeu de résultats est tronqué.<br /><br /> SQL_ATTR_MAX_ROWS s’applique à tous les jeux de résultats de l' *instruction*, y compris ceux retournés par les fonctions de catalogue. SQL_ATTR_MAX_ROWS établit un maximum pour la valeur du nombre de lignes du curseur.<br /><br /> Un pilote ne doit pas émuler SQL_ATTR_MAX_ROWS comportement pour **SQLFetch** ou **SQLFetchScroll** (si les limitations de taille du jeu de résultats ne peuvent pas être implémentées au niveau de la source de données) s’il ne peut pas garantir que SQL_ATTR_MAX_ROWS sera implémentée correctement.<br /><br /> Elle est définie par le pilote, que SQL_ATTR_MAX_ROWS s’applique aux instructions autres que les instructions SELECT (telles que les fonctions de catalogue).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut ne pas prendre effet immédiatement, auquel cas le pilote retourne SQLSTATE 01S02 ne (valeur d’option modifiée) et rétablit l’attribut à sa valeur d’origine.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Valeur SQLULEN qui détermine la façon dont les arguments de chaîne des fonctions de catalogue sont traités.<br /><br /> Si SQL_TRUE, l’argument de chaîne des fonctions de catalogue est traité comme des identificateurs. Le cas n’est pas significatif. Pour les chaînes non délimitées, le pilote supprime tous les espaces de fin et la chaîne est pliée en majuscules. Pour les chaînes délimitées, le pilote supprime tous les espaces de début ou de fin et prend tout ce qui se trouve entre les délimiteurs littéralement. Si l’un de ces arguments est défini sur un pointeur null, la fonction retourne SQL_ERROR et SQLSTATE HY009 (utilisation non valide du pointeur null).<br /><br /> Si SQL_FALSE, les arguments de chaîne des fonctions de catalogue ne sont pas traités comme des identificateurs. Le cas est significatif. Ils peuvent contenir un modèle de recherche de chaîne ou non, en fonction de l’argument.<br /><br /> La valeur par défaut est SQL_FALSE.<br /><br /> L’argument *TABLETYPE* de **SQLTables**, qui prend une liste de valeurs, n’est pas affecté par cet attribut.<br /><br /> SQL_ATTR_METADATA_ID peut également être défini au niveau de la connexion. (Et les SQL_ATTR_ASYNC_ENABLE sont les seuls attributs d’instruction qui sont également des attributs de connexion.)<br /><br /> Pour plus d’informations, consultez [arguments dans les fonctions de catalogue](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Valeur SQLULEN qui indique si le pilote doit analyser les chaînes SQL pour les séquences d’échappement :<br /><br /> SQL_NOSCAN_OFF = le pilote analyse les chaînes SQL pour les séquences d’échappement (valeur par défaut).<br /><br /> SQL_NOSCAN_ON = le pilote n’analyse pas les chaînes SQL pour les séquences d’échappement. Au lieu de cela, le pilote envoie l’instruction directement à la source de données.<br /><br /> Pour plus d’informations, consultez [séquences d’échappement dans ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Valeur SQLULEN * qui pointe vers un offset ajouté aux pointeurs pour modifier la liaison des paramètres dynamiques. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Elle a la valeur NULL par défaut.<br /><br /> L’offset de liaison est toujours ajouté directement aux champs SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR. Si le décalage est remplacé par une autre valeur, la nouvelle valeur est toujours ajoutée directement à la valeur dans le champ descripteur. Le nouvel offset n’est pas ajouté à la valeur de champ plus les décalages précédents.<br /><br /> Pour plus d’informations, consultez [décalages de liaison de paramètre](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Valeur SQLULEN qui indique l’orientation de liaison à utiliser pour les paramètres dynamiques.<br /><br /> Ce champ est défini sur SQL_PARAM_BIND_BY_COLUMN (valeur par défaut) pour sélectionner une liaison selon les colonnes.<br /><br /> Pour sélectionner une liaison selon les lignes, ce champ est défini sur la longueur de la structure ou sur une instance d’une mémoire tampon qui sera liée à un ensemble de paramètres dynamiques. Cette longueur doit inclure l’espace pour tous les paramètres liés et tout remplissage de la structure ou de la mémoire tampon pour garantir que lorsque l’adresse d’un paramètre lié est incrémentée avec la longueur spécifiée, le résultat pointe vers le début du même paramètre dans la prochaine ensemble de paramètres. Lorsque vous utilisez l’opérateur *sizeof* en C ANSI, ce comportement est garanti.<br /><br /> Pour plus d’informations, consultez [liaison de tableaux de paramètres](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit l’SQL_DESC_ champ BIND_TYPE dans l’en-tête APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Valeur SQLUSMALLINT \* qui pointe vers un tableau de valeurs SQLUSMALLINT utilisées pour ignorer un paramètre pendant l’exécution d’une instruction SQL. Chaque valeur est définie sur SQL_PARAM_PROCEED (pour le paramètre à exécuter) ou SQL_PARAM_IGNORE (pour le paramètre à ignorer).<br /><br /> Un ensemble de paramètres peut être ignoré lors du traitement en définissant la valeur d’État dans le tableau désigné par SQL_DESC_ARRAY_STATUS_PTR dans le APD à SQL_PARAM_IGNORE. Un ensemble de paramètres est traité si sa valeur d’État est définie sur SQL_PARAM_PROCEED ou si aucun élément du tableau n’est défini.<br /><br /> Cet attribut d’instruction peut être défini sur un pointeur null, auquel cas le pilote ne retourne pas de valeurs d’état de paramètre. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu’à la prochaine exécution de **SQLExecDirect** ou **SQLExecute** .<br /><br /> Cet attribut est ignoré en l’absence de paramètre lié.<br /><br /> Pour plus d’informations, consultez [utilisation de tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Valeur SQLUSMALLINT \* qui pointe vers un tableau de valeurs SQLUSMALLINT contenant des informations d’État pour chaque ligne de valeurs de paramètre après un appel à **SQLExecute** ou **SQLExecDirect**. Ce champ est obligatoire uniquement si PARAMSET_SIZE est supérieur à 1.<br /><br /> Les valeurs d’État peuvent contenir les valeurs suivantes :<br /><br /> SQL_PARAM_SUCCESS : l’instruction SQL a été exécutée avec succès pour cet ensemble de paramètres.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO : l’instruction SQL a été exécutée avec succès pour cet ensemble de paramètres ; Toutefois, les informations d’avertissement sont disponibles dans la structure des données de diagnostic.<br /><br /> SQL_PARAM_ERROR : une erreur s’est produite lors du traitement de cet ensemble de paramètres. Des informations supplémentaires sur l’erreur sont disponibles dans la structure des données de diagnostic.<br /><br /> SQL_PARAM_UNUSED : ce jeu de paramètres n’était pas utilisé, peut-être en raison du fait qu’un jeu de paramètres précédent a provoqué une erreur qui a abandonné un traitement supplémentaire ou parce que SQL_PARAM_IGNORE a été défini pour cet ensemble de paramètres dans le tableau spécifié par le SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE : le pilote traite les tableaux de paramètres comme une unité monolithique et ne génère donc pas ce niveau d’informations d’erreur.<br /><br /> Cet attribut d’instruction peut être défini sur un pointeur null, auquel cas le pilote ne retourne pas de valeurs d’état de paramètre. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu’à la prochaine appel à **SQLExecute** ou à **SQLExecDirect** . Notez que la définition de cet attribut peut affecter le comportement du paramètre de sortie implémenté par le pilote.<br /><br /> Pour plus d’informations, consultez [utilisation de tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|Champ d' \* enregistrement SQLULEN qui pointe vers une mémoire tampon dans laquelle retourner le nombre d’ensembles de paramètres qui ont été traités, y compris les ensembles d’erreurs. Aucun nombre n’est retourné s’il s’agit d’un pointeur null.<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête IPD.<br /><br /> Si l’appel à **SQLExecDirect** ou à **SQLExecute** qui remplit la mémoire tampon vers laquelle pointe cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.<br /><br /> Pour plus d’informations, consultez [utilisation de tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Valeur SQLULEN qui spécifie le nombre de valeurs pour chaque paramètre. Si SQL_ATTR_PARAMSET_SIZE est supérieur à 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR de APD pointer vers des tableaux. La cardinalité de chaque tableau est égale à la valeur de ce champ.<br /><br /> Cet attribut est ignoré en l’absence de paramètre lié.<br /><br /> Pour plus d’informations, consultez [utilisation de tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Valeur SQLULEN correspondant au nombre de secondes d’attente de l’exécution d’une instruction SQL avant le retour à l’application. Si *ValuePtr* est égal à 0 (valeur par défaut), il n’y a aucun délai d’attente.<br /><br /> Si le délai d’expiration spécifié dépasse le délai d’attente maximal dans la source de données ou est inférieur au délai d’expiration minimal, **SQLSetStmtAttr** remplace cette valeur et retourne SQLState 01s02 ne (valeur d’option modifiée).<br /><br /> Notez que l’application n’a pas besoin d’appeler **SQLCloseCursor** pour réutiliser l’instruction si une instruction **Select** a dépassé le délai d’attente.<br /><br /> Le délai d’attente de requête défini dans cet attribut d’instruction est valide en mode synchrone et asynchrone.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Valeur SQLULEN :<br /><br /> SQL_RD_ON = **SQLFetchScroll** et, dans ODBC *3. x*, **SQLFetch** récupère les données après avoir positionné le curseur à l’emplacement spécifié. Il s’agit de la valeur par défaut.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** et, dans ODBC *3. x*, **SQLFetch** ne récupère pas les données après avoir positionné le curseur.<br /><br /> En définissant SQL_RETRIEVE_DATA sur SQL_RD_OFF, une application peut vérifier qu’une ligne existe ou récupérer un signet pour la ligne sans impliquer la surcharge liée à la récupération des lignes. Pour plus d’informations, consultez [défilement et extraction de lignes](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut ne pas prendre effet immédiatement, auquel cas le pilote retourne SQLSTATE 01S02 ne (valeur d’option modifiée) et rétablit l’attribut à sa valeur d’origine.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Valeur SQLULEN qui spécifie le nombre de lignes retournées par chaque appel à **SQLFetch** ou **SQLFetchScroll**. Il s’agit également du nombre de lignes dans un tableau de signets utilisé dans une opération de signet en bloc dans **SQLBulkOperations**. La valeur par défaut est 1.<br /><br /> Si la taille d’ensemble de lignes spécifiée dépasse la taille maximale de l’ensemble de lignes prise en charge par la source de données, le pilote remplace cette valeur et retourne SQLSTATE 01S02 ne (valeur d’option modifiée).<br /><br /> Pour plus d’informations, consultez taille de l' [ensemble de lignes](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Valeur SQLULEN * qui pointe vers un offset ajouté aux pointeurs pour modifier la liaison des données de colonne. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Elle a la valeur NULL par défaut.<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Valeur SQLULEN qui définit l’orientation de liaison à utiliser lorsque **SQLFetch** ou **SQLFetchScroll** est appelé sur l’instruction associée. La liaison selon les colonnes est sélectionnée en affectant à la valeur SQL_BIND_BY_COLUMN. La liaison selon les lignes est sélectionnée en affectant à la valeur la longueur d’une structure ou une instance d’une mémoire tampon dans laquelle les colonnes de résultat seront liées.<br /><br /> Si une longueur est spécifiée, elle doit inclure l’espace pour toutes les colonnes liées et tout remplissage de la structure ou de la mémoire tampon pour garantir que lorsque l’adresse d’une colonne liée est incrémentée avec la longueur spécifiée, le résultat pointe vers le début de la même colonne en Th ligne suivante. Lorsque vous utilisez l’opérateur **sizeof** avec des structures ou des unions en C ANSI, ce comportement est garanti.<br /><br /> La liaison selon les colonnes est l’orientation de liaison par défaut pour **SQLFetch** et **SQLFetchScroll**.<br /><br /> Pour plus d’informations, consultez [lier des colonnes à utiliser avec des curseurs de bloc](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_TYPE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Valeur SQLULEN qui est le numéro de la ligne actuelle dans le jeu de résultats entier. Si le numéro de la ligne actuelle ne peut pas être déterminé ou s’il n’y a pas de ligne actuelle, le pilote retourne 0.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** , mais n’est pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Valeur SQLUSMALLINT \* qui pointe vers un tableau de valeurs SQLUSMALLINT utilisées pour ignorer une ligne pendant une opération en bloc à l’aide de **SQLSetPos**. Chaque valeur est définie sur SQL_ROW_PROCEED (pour la ligne à inclure dans l’opération en bloc) ou SQL_ROW_IGNORE (pour la ligne à exclure de l’opération en bloc). (Les lignes ne peuvent pas être ignorées à l’aide de ce tableau lors des appels à **SQLBulkOperations**.)<br /><br /> Cet attribut d’instruction peut être défini sur un pointeur null, auquel cas le pilote ne retourne pas de valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu’à la prochaine fois que **SQLSetPos** est appelé.<br /><br /> Pour plus d’informations, consultez [mise à jour de lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) et [Suppression de lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Valeur SQLUSMALLINT \* qui pointe vers un tableau de valeurs SQLUSMALLINT contenant les valeurs d’état de ligne après un appel à **SQLFetch** ou **SQLFetchScroll**. Le tableau contient autant d’éléments qu’il y a de lignes dans l’ensemble de lignes.<br /><br /> Cet attribut d’instruction peut être défini sur un pointeur null, auquel cas le pilote ne retourne pas de valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée tant que la prochaine fois que **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**ou **SQLSetPos** n’est pas appelé.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête IRD.<br /><br /> Cet attribut est mappé par un pilote ODBC *2. x* au tableau *rgbRowStatus* dans un appel à **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Valeur SQLULEN \* qui pointe vers une mémoire tampon dans laquelle retourner le nombre de lignes extraites après un appel à **SQLFetch** ou **SQLFetchScroll**; nombre de lignes affectées par une opération en bloc effectuée par un appel à **SQLSetPos** avec un argument d' *opération* SQL_REFRESH ; ou le nombre de lignes affectées par une opération en bloc effectuée par **SQLBulkOperations**. Ce nombre comprend les lignes d’erreur.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête IRD.<br /><br /> Si l’appel à **SQLFetch** ou **SQLFetchScroll** qui remplit la mémoire tampon vers laquelle pointe cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Valeur de SQLULEN qui spécifie si les pilotes qui simulent des instructions de mise à jour et de suppression positionnées garantissent que ces instructions n’affectent qu’une seule ligne.<br /><br /> Pour simuler des instructions Update et DELETE positionnées, la plupart des pilotes créent une instruction **Update** ou **Delete** recherchée contenant une clause **Where** qui spécifie la valeur de chaque colonne dans la ligne actuelle. À moins que ces colonnes composent une clé unique, une telle instruction peut affecter plusieurs lignes.<br /><br /> Pour garantir que ces instructions n’affectent qu’une seule ligne, le pilote détermine les colonnes dans une clé unique et ajoute ces colonnes au jeu de résultats. Si une application garantit que les colonnes du jeu de résultats composent une clé unique, le pilote n’est pas obligé de le faire. Cela peut réduire le temps d’exécution.<br /><br /> SQL_SC_NON_UNIQUE = le pilote ne garantit pas que les instructions de mise à jour ou de suppression positionnées ne concernent qu’une seule ligne ; Il incombe à l’application de le faire. Si une instruction affecte plus d’une ligne, **SQLExecute**, **SQLExecDirect**ou **SQLSetPos** retourne SQLState 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_TRY_UNIQUE = le pilote tente de garantir que les instructions Update ou DELETE positionnées n’affectent qu’une seule ligne. Le pilote exécute toujours ces instructions, même si elles peuvent affecter plusieurs lignes, par exemple en l’absence de clé unique. Si une instruction affecte plus d’une ligne, **SQLExecute**, **SQLExecDirect**ou **SQLSetPos** retourne SQLState 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_UNIQUE = le pilote garantit que les instructions Update ou DELETE positionnées n’affectent qu’une seule ligne. Si le pilote ne peut pas garantir cela pour une instruction donnée, **SQLExecDirect** ou **SQLPrepare** retourne une erreur.<br /><br /> Si la source de données fournit la prise en charge SQL Native pour les instructions Update et DELETE positionnées et que le pilote ne simule pas les curseurs, SQL_SUCCESS est retourné lorsque SQL_SC_UNIQUE est demandée pour SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO est retourné si SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE est demandé. Si la source de données fournit le niveau de prise en charge SQL_SC_TRY_UNIQUE et que le pilote ne le fait pas, SQL_SUCCESS est retourné pour SQL_SC_TRY_UNIQUE et SQL_SUCCESS_WITH_INFO est retourné pour SQL_SC_NON_UNIQUE.<br /><br /> Si le type de simulation de curseur spécifié n’est pas pris en charge par la source de données, le pilote remplace un type de simulation différent et retourne SQLSTATE 01S02 ne (valeur d’option modifiée). Par SQL_SC_UNIQUE, le pilote remplace, dans l’ordre, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Par SQL_SC_TRY_UNIQUE, le pilote remplace SQL_SC_NON_UNIQUE.<br /><br /> La valeur par défaut est SQL_SC_UNIQUE.<br /><br /> Pour plus d’informations, consultez [simulation d’instructions de mise à jour et de suppression positionnées](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Valeur SQLULEN qui spécifie si une application utilise des signets avec un curseur :<br /><br /> SQL_UB_OFF = OFF (valeur par défaut)<br /><br /> SQL_UB_VARIABLE = une application utilisera des signets avec un curseur, et le pilote fournira des signets de longueur variable s’ils sont pris en charge. SQL_UB_FIXED est déconseillé dans ODBC *3. x*. Les applications ODBC *3. x* doivent toujours utiliser des signets de longueur variable, même lorsque vous utilisez des pilotes ODBC *2. x* (qui ne prenait en charge que les signets de longueur fixe de 4 octets). Cela est dû au fait qu’un signet de longueur fixe est simplement un cas spécial d’un signet de longueur variable. Lorsque vous utilisez un pilote ODBC *2. x* , le gestionnaire de pilotes mappe SQL_UB_VARIABLE à SQL_UB_FIXED.<br /><br /> Pour utiliser des signets avec un curseur, l’application doit spécifier cet attribut avec la valeur SQL_UB_VARIABLE avant d’ouvrir le curseur.<br /><br /> Pour plus d’informations, consultez [récupération de signets](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] ces fonctions peuvent être appelées de façon asynchrone uniquement si le descripteur est un descripteur d’implémentation et non un descripteur d’application.  
  
 Consultez [liaison](../../../odbc/reference/develop-app/column-wise-binding.md) selon les colonnes et [liaison](../../../odbc/reference/develop-app/row-wise-binding.md)selon les lignes.  
  
## <a name="related-functions"></a>Fonctions connexes  
  
|Pour obtenir des informations sur|Consultez|  
|---------------------------|---------|  
|Annulation du traitement des instructions|[SQLCancel, fonction](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Renvoi du paramètre d’un attribut de connexion|[Fonction SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Renvoi du paramètre d’un attribut d’instruction|[Fonction SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Définition d’un attribut de connexion|[Fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Définition d’un champ unique du descripteur|[SQLSetDescField, fonction](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Voir aussi  
 [Informations de référence sur l’API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Fichiers d’en-tête ODBC](../../../odbc/reference/install/odbc-header-files.md)
